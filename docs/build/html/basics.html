

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Basics of Geometric Multigrid &mdash; Multigrid 1.0.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Results of Multigrid for Convection Diffusion" href="Multigrid.html" />
    <link rel="prev" title="Welcome to Multigrid’s documentation!" href="index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Multigrid
          

          
            
            <img src="_static/logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Table of Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Basics of Geometric Multigrid</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#problem-setup">Problem setup</a></li>
<li class="toctree-l2"><a class="reference internal" href="#finite-element-method">Finite Element Method</a></li>
<li class="toctree-l2"><a class="reference internal" href="#iterative-methods">Iterative Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="#grid-setup">Grid Setup</a></li>
<li class="toctree-l2"><a class="reference internal" href="#two-grid-algorithm">Two-grid algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="#multigrid-algorithm">Multigrid algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="#grid-transfer">Grid transfer</a></li>
<li class="toctree-l2"><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Multigrid.html">Results of Multigrid for Convection Diffusion</a></li>
<li class="toctree-l1"><a class="reference internal" href="license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="help.html">Help</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Multigrid</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Basics of Geometric Multigrid</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/basics.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="basics-of-geometric-multigrid">
<h1>Basics of Geometric Multigrid<a class="headerlink" href="#basics-of-geometric-multigrid" title="Permalink to this headline">¶</a></h1>
<style> .blue {color:#3636eb;} </style><style> .red {color:#cc0000;} </style><div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>In the following, we are describing the <span class="blue">geometric multigrid method</span>,
which for certain problems yields an iterative solver
with optimal cost complexity, i.e. the solver returns a solution to a PDE in
<span class="math notranslate nohighlight">\(O(n_{\text{DoFs}})\)</span> arithmetic operations. We will show that this can also
be achieved for some convection-diffusion equations on uniformly refined triangular
meshes, when discretizing with linear finite elements.</p>
</div>
<div class="section" id="problem-setup">
<h2>Problem setup<a class="headerlink" href="#problem-setup" title="Permalink to this headline">¶</a></h2>
<p>Let <span class="math notranslate nohighlight">\(\Omega := (-1,1)^2 \setminus (0,1)^2\)</span> be an L-shaped <span class="blue">domain</span>. We decompose the boundary of this domain <span class="math notranslate nohighlight">\(\partial\Omega\)</span> into the Neumann boundary <span class="math notranslate nohighlight">\(\Gamma_D := (0,1) \times \{0\} \cup \{0\} \times (0,1)\)</span>
and the Dirichlet boundary <span class="math notranslate nohighlight">\(\Gamma_N := \partial\Omega \setminus \Gamma_D\)</span>.</p>
<p>Next, we define the <span class="blue">ansatz</span> and <span class="blue">test function space</span> <span class="math notranslate nohighlight">\(V := \left\{ u \in H^1(\Omega)\mid u = 0 \text{ on } \Gamma_D \right\}\)</span>,
where</p>
<div class="math notranslate nohighlight">
\[H^1(\Omega) := W^{1,2}(\Omega) := \left\{ u \in L^2(\Omega) \mid |\nabla u| \in L^2( \Omega ) \right\}\]</div>
<p>is the Sobolev space containing the weakly differentiable functions
in <span class="math notranslate nohighlight">\(\Omega\)</span>. Note that we haven’t explicitly prescribed any boundary conditions on <span class="math notranslate nohighlight">\(\Gamma_N\)</span> in the function space,
since the homogeneous Neumann boundary conditions come up naturally when deriving the variational form of the problem.
Further, we need a right hand side function</p>
<div class="math notranslate nohighlight">
\[\begin{split}f(x) :=
\begin{cases}
   -1 &amp; \text{for } x \in (-1,0) \times (0,1) \\
   0 &amp; \text{for } x \in (-1,0) \times (-1,0) \\
   1 &amp; \text{for } x \in (0,1) \times (-1,0) \\
\end{cases}.\end{split}\]</div>
<div class="figure align-center">
<img alt="domain" src="_images/domain.svg" /></div>
<p class="centered">
<strong>Figure 1: Domain <span class="math notranslate nohighlight">\(\Omega\)</span></strong></p><p>Using the parameters <span class="math notranslate nohighlight">\(a = 1\)</span> and <span class="math notranslate nohighlight">\(c = 0\)</span> in <span class="math notranslate nohighlight">\(\Omega\)</span>, we can now
formulate the strong form of our convection diffusion equation:</p>
<div class="admonition-strong-form admonition">
<p class="admonition-title">Strong form</p>
<p>Find <span class="math notranslate nohighlight">\(u: \Omega \rightarrow \mathbb{R}\)</span> such that</p>
<div class="math notranslate nohighlight">
\[\begin{split}-\nabla \cdot \left( a \nabla u\right) + c u &amp;= f \quad \text{in } \Omega \qquad (1)\\
u &amp;= 0 \quad \text{on } \Gamma_D \\
\partial_n u &amp;= 0 \quad \text{on } \Gamma_N\end{split}\]</div>
</div>
<p>In the above formulation, we used the notation <span class="math notranslate nohighlight">\(\partial n := \nabla \cdot n\)</span>.
To be able to solve this problem, we need to convert it into its integral form.
Therefore we multiply (1) from the right with a test function <span class="math notranslate nohighlight">\(v \in V\)</span> and integrate over <span class="math notranslate nohighlight">\(\Omega\)</span>.</p>
<div class="math notranslate nohighlight">
\[-\int_{\Omega} \left(\nabla \cdot \left( a \nabla u\right)\right) \cdot v\ dx
+ \int_{\Omega} c u \cdot v\ dx
= \int_{\Omega} f \cdot v\ dx \quad \forall v \in V\]</div>
<p>Now integration of parts can be applied to the first integral and we use the fact that <span class="math notranslate nohighlight">\(\partial \Omega = \Gamma_D\ \dot\cup\ \Gamma_N\)</span>.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\int_{\Omega} a \nabla u \cdot \nabla v\ dx
-\int_{\Gamma_D} a \partial_n u \cdot v\ ds
-\int_{\Gamma_N} a \partial_n u \cdot v\ ds \\
+ \int_{\Omega} c u \cdot v\ dx
= \int_{\Omega} f \cdot v\ dx \quad \forall v \in V\end{split}\]</div>
<p>Note that the integrals over the boundaries <span class="math notranslate nohighlight">\(\Gamma_D\)</span> and <span class="math notranslate nohighlight">\(\Gamma_N\)</span> vanish,
since <span class="math notranslate nohighlight">\(\partial_n u = 0\)</span> on <span class="math notranslate nohighlight">\(\Gamma_N\)</span> and, due to <span class="math notranslate nohighlight">\(v \in V\)</span>, <span class="math notranslate nohighlight">\(u = 0\)</span> on <span class="math notranslate nohighlight">\(\Gamma_D\)</span>.
Thus we have derived the following integral problem of our problem,
which is often referred to as the weak or variational form in the literature.</p>
<div class="admonition-weak-form admonition">
<p class="admonition-title">Weak form</p>
<p>Find <span class="math notranslate nohighlight">\(u \in V\)</span> such that</p>
<div class="math notranslate nohighlight">
\[a(u,v) = l(v) \quad \forall v \in V\]</div>
<p>where <span class="math notranslate nohighlight">\(a: V \times V \rightarrow \mathbb{R}\)</span> is the bilinear form defined as</p>
<div class="math notranslate nohighlight">
\[a(u,v) := \int_{\Omega} a \nabla u \cdot \nabla v\ dx + \int_{\Omega} c u \cdot v\ dx\]</div>
<p>and the right hand side <span class="math notranslate nohighlight">\(l: V \rightarrow \mathbb{R}\)</span> is a linear form defined as</p>
<div class="math notranslate nohighlight">
\[l(v) := \int_{\Omega} f \cdot v\ dx\]</div>
</div>
<p>Furthermore using the fundamental lemma of calculus of variations, it can be shown that the strong and the weak form
are equivalent. Hence it suffices to solve the weak form of the problem.</p>
</div>
<div class="section" id="finite-element-method">
<h2>Finite Element Method<a class="headerlink" href="#finite-element-method" title="Permalink to this headline">¶</a></h2>
<p>The problem that we are facing is that <span class="math notranslate nohighlight">\(V\)</span> is an infinite dimensional function space
and we need the ability to solve the weak form with a classical computer.
Hence instead we work with a finite dimensional subspace <span class="math notranslate nohighlight">\(V_h \subset V\)</span>.
This will enable us to rewrite the weak form as a linear equation system.</p>
<p>Let a subdivision of <span class="math notranslate nohighlight">\(\Omega\)</span> into <span class="blue">finite elements</span> <span class="math notranslate nohighlight">\((K,P_1,\Sigma)\)</span>
be given, where</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(K\)</span> is a two dimensional right triangle,</p></li>
<li><p><span class="math notranslate nohighlight">\(P_1(K) := \operatorname{span}\{1-x_1-x_2, x_1, x_2 \}\)</span> is the space of linear functions defined on <span class="math notranslate nohighlight">\(K\)</span>,</p></li>
<li><p><span class="math notranslate nohighlight">\(\Sigma := \{a_0, a_1, a_2 \}\)</span> is a set of <span class="blue">degrees of freedom</span> (DoF), which here are the values of the polynomial at the vertices of <span class="math notranslate nohighlight">\(K\)</span>.</p></li>
</ul>
<p>Then a <span class="math notranslate nohighlight">\(P_1(K)\)</span> function is defined by</p>
<div class="math notranslate nohighlight">
\[u(x) = a_0 + a_1x_1 + a_2x_2 \quad \forall x = (x_1,x_2) \in K.\]</div>
<p>To recapitulate: First, we have divided <span class="math notranslate nohighlight">\(\Omega\)</span> into triangles <span class="math notranslate nohighlight">\(K_1, ..., K_m\)</span>. Examples for this can be found in the section <a class="reference external" href="#grid-setup">“Grid Setup”</a>.
Secondly, we have seen that we have the parameters (DoFs) which can describe any linear function on such a triangle <span class="math notranslate nohighlight">\(K_k\)</span>.
Now simply define our function space <span class="math notranslate nohighlight">\(V_h\)</span> as the space of functions which are continuous on the whole domain <span class="math notranslate nohighlight">\(\Omega\)</span>, linear on each triangle <span class="math notranslate nohighlight">\(K_k\)</span> and satisfy the Dirichlet boundary conditions, i.e.</p>
<div class="math notranslate nohighlight">
\[V_h := \{ v_h \in C(\Omega) \mid v_h |_{K_k} \in P_1(K_k) \quad \forall 1 \leq k \leq m,\ v_h = 0 \text{ on } \Gamma_D \}.\]</div>
<p>We use the index <span class="math notranslate nohighlight">\(h\)</span> to show that we are not longer using the infinite dimensional function space <span class="math notranslate nohighlight">\(V\)</span>,
but a finite dimensional subspace which is defined on triangles <span class="math notranslate nohighlight">\(K_k\)</span> where the short sides have length <span class="math notranslate nohighlight">\(h\)</span>.
By working with <span class="math notranslate nohighlight">\(V_h\)</span>, we now try to find an element-wise linear approximation to the solution of the weak form.</p>
<p>Thus we are now trying to solve the discrete weak form:</p>
<div class="admonition-discrete-weak-form admonition">
<p class="admonition-title">Discrete weak form</p>
<p>Find <span class="math notranslate nohighlight">\(u_h \in V_h\)</span> such that</p>
<div class="math notranslate nohighlight">
\[a(u_h,v_h) = l(v_h) \quad \forall v_h \in V_h\]</div>
</div>
<p>Furthermore, we know that <span class="math notranslate nohighlight">\(V_h\)</span> is finite dimensional and we can write down its basis, since we know the bases of <span class="math notranslate nohighlight">\(P_1(K_k)\)</span>.
Hence</p>
<div class="math notranslate nohighlight">
\[V_h = \operatorname{span}\{ \phi_1, \dots, \phi_{n_{DoFs}} \},\]</div>
<p>where <span class="math notranslate nohighlight">\(\phi_i\)</span> is the basis function corresponding to the i.th degree of freedom, i.e. the i.th grid point. It follows that</p>
<div class="math notranslate nohighlight">
\[u_h = \sum_{i= 0}^{n_{DoFs}} u_i \phi_i \quad \text{and} \quad v_h = \sum_{i= 0}^{n_{DoFs}} v_i \phi_i\]</div>
<p>for some <span class="math notranslate nohighlight">\(\begin{pmatrix}u_1, \dots u_{n_{DoFs}}\end{pmatrix}^T, \begin{pmatrix}v_1, \dots v_{n_{DoFs}}\end{pmatrix}^T \in \mathbb{R}^{n_{DoFs}}\)</span>. Therefore the discrete weak form can be written as</p>
<div class="math notranslate nohighlight">
\[a\left(\sum_{i= 0}^{n_{DoFs}} u_i \phi_i,\sum_{j= 0}^{n_{DoFs}} v_j \phi_j \right) = l\left(\sum_{j= 0}^{n_{DoFs}} v_j \phi_j \right).\]</div>
<p>Since <span class="math notranslate nohighlight">\(a\)</span> is linear in the second argument and <span class="math notranslate nohighlight">\(l\)</span> is also linear, it is thus sufficient to solve</p>
<div class="math notranslate nohighlight">
\[a\left(\sum_{i= 0}^{n_{DoFs}} u_i \phi_i,\phi_j \right) = l\left(\phi_j \right) \quad \forall 1 \leq j \leq n_{DoFs}.\]</div>
<p>The convection-diffusion problem is linear itself, thus <span class="math notranslate nohighlight">\(a\)</span> is also linear in the first argument and we get</p>
<div class="math notranslate nohighlight">
\[\sum_{i= 0}^{n_{DoFs}} u_i\ a\left(\phi_i,\phi_j \right) = l\left(\phi_j \right) \quad \forall 1 \leq j \leq n_{DoFs}.\]</div>
<p>This can also be written as a linear equation system</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{bmatrix}
  a\left(\phi_1,\phi_1 \right) &amp; \cdots &amp; a\left(\phi_{n_{DoFs}},\phi_1 \right) \\
  \vdots &amp; \ddots &amp; \vdots \\
  a\left(\phi_1,\phi_{n_{DoFs}} \right) &amp; \cdots &amp; a\left(\phi_{n_{DoFs}},\phi_{n_{DoFs}} \right)
\end{bmatrix}
\begin{bmatrix}
  u_1\\
  \vdots\\
  u_{n_{DoFs}}
\end{bmatrix}
=
\begin{bmatrix}
  l(u_1)\\
  \vdots\\
  l(u_{n_{DoFs}})
\end{bmatrix}.\end{split}\]</div>
<p>To remain consistent with future chapters, we follow the naming convention</p>
<div class="math notranslate nohighlight">
\[\begin{split}A_h &amp;:= \begin{bmatrix}
  a\left(\phi_1,\phi_1 \right) &amp; \cdots &amp; a\left(\phi_{n_{DoFs}},\phi_1 \right) \\
  \vdots &amp; \ddots &amp; \vdots \\
  a\left(\phi_1,\phi_{n_{DoFs}} \right) &amp; \cdots &amp; a\left(\phi_{n_{DoFs}},\phi_{n_{DoFs}} \right)
\end{bmatrix}, \\
x_h &amp;:= \begin{bmatrix}
  u_1\\
  \vdots\\
  u_{n_{DoFs}}
\end{bmatrix}  \quad \text{ and } \\
b_h &amp;:= \begin{bmatrix}
  l(u_1)\\
  \vdots\\
  l(u_{n_{DoFs}})
\end{bmatrix}.\end{split}\]</div>
<p>To be able to solve <span class="math notranslate nohighlight">\(A_h x_h = b_h\)</span>, we need an efficient way to compute <span class="math notranslate nohighlight">\(a\left(\phi_i,\phi_j \right)\)</span> and <span class="math notranslate nohighlight">\(l\left(\phi_j \right)\)</span>.
For that we use that <span class="math notranslate nohighlight">\(\Omega = \cup_{k = 1}^{n_{DoFs}}K_k\)</span> and we thus get</p>
<div class="math notranslate nohighlight">
\[\begin{split}a(\phi_i,\phi_j) &amp;= \int_{\Omega} a \nabla \phi_i \cdot \nabla \phi_j\ dx + \int_{\Omega} c \phi_i \cdot \phi_j\ dx \\
                &amp;= \sum_{k = 1}^{n_{DoFs}} \left( \int_{K_k} a \nabla \phi_i \cdot \nabla \phi_j\ dx + \int_{K_k} c \phi_i \cdot \phi_j\ dx  \right),\end{split}\]</div>
<p>similarly we get for the right hand functional</p>
<div class="math notranslate nohighlight">
\[\begin{split}l(\phi_j) &amp;= \int_{\Omega} f \cdot \phi_j\ dx \\
          &amp;= \sum_{k = 1}^{n_{DoFs}} \left( \int_{K_k} f \cdot \phi_j\ dx \right).\end{split}\]</div>
<p>Note that many of these integrals are zero, since the basis functions <span class="math notranslate nohighlight">\(\phi_i\)</span> only have support on the triangles that contain the vertex corresponding
to the i.th degree of freedom. Furthermore, we use the isoparametric concept that allows us to assemble the <span class="blue">system matrix</span> <span class="math notranslate nohighlight">\(A_h\)</span> and <span class="blue">right side</span> <span class="math notranslate nohighlight">\(b_h\)</span>
by once computing integrals on a reference element <span class="math notranslate nohighlight">\(\hat{K}\)</span> and then transforming the results to the elements <span class="math notranslate nohighlight">\(K_k\)</span>.</p>
<div class="figure align-center">
<img alt="trafo" src="_images/trafo.png" />
</div>
<p class="centered">
<strong>Figure 2: Transformation from reference element to finite element</strong></p><p>We now apply the transformation theorem</p>
<div class="math notranslate nohighlight">
\[\int_{\hat{K}} g\left(T_k\left(\hat{x}\right)\right)\left|\det\left(\nabla T_k\left(\hat{x}\right)\right)\right|\ d\hat{x} = \int_{K_k} g\left(x\right)\ dx\]</div>
<p>to all integrals that need to be evaluated in the discrete weak form.</p>
<p>Then the algorithm for the assembly is given by</p>
<div class="figure align-center">
<img alt="assembly" src="_images/assembly.png" />
</div>
<p>where <span class="math notranslate nohighlight">\(\hat{\phi}_i = \phi_i \circ T_k\)</span> are the basis functions on the reference element.</p>
<p>At the end of the assembly, we need to account for the Dirichlet boundary constraints, e.g. let a constraint <span class="math notranslate nohighlight">\(u_{\tau} = \xi\)</span> be given.
Then we would need to make sure that <span class="math notranslate nohighlight">\((A_h)_{\tau,j} = \delta_{\tau,j}\)</span> for all <span class="math notranslate nohighlight">\(1 \leq j \leq m\)</span>.
Here <span class="math notranslate nohighlight">\(\delta_{\tau,j}\)</span> denotes the Kronecker delta, which is defined as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\delta_{\tau,j} := \begin{cases}
  1 &amp; \text{for } j = \tau \\
  0 &amp; \text{for } j \neq \tau
  \end{cases}.\end{split}\]</div>
<p>Futhermore, we would need to set <span class="math notranslate nohighlight">\((b_h)_{\tau} = \xi\)</span>.
Obviously these steps ensure that when solving the linear system <span class="math notranslate nohighlight">\(A_h x_h = b_h\)</span>,
we get <span class="math notranslate nohighlight">\(u_{\tau} = \xi\)</span>. In our model problem, we only have homogeneous Dirichlet constraints.
Thus, we only need to find all indices <span class="math notranslate nohighlight">\(\tau\)</span> at the Dirichlet boundary <span class="math notranslate nohighlight">\(\Gamma_D\)</span>
and apply the procedure from above with <span class="math notranslate nohighlight">\(\xi = 0\)</span>.</p>
<p>Overall, the Finite Element Method enabled us to transform a discrete form of the convection-diffusion equation
on a given grid into a linear equation system. In the following, we will investigate how such a linear equation system can be solved iteratively.</p>
</div>
<div class="section" id="iterative-methods">
<h2>Iterative Methods<a class="headerlink" href="#iterative-methods" title="Permalink to this headline">¶</a></h2>
<p>We want to construct an iteration, where each iterate <span class="math notranslate nohighlight">\(x_k^{k}\)</span> is a better approximation to the linear equation system <span class="math notranslate nohighlight">\(A_h x_h = b_h\)</span>.
To measure the quality of our solution, we monitor the <span class="blue">defect</span></p>
<div class="math notranslate nohighlight">
\[b_h - A_h x_h\]</div>
<p>and try to minimize it.
One can try to formulate a fixed point scheme <span class="math notranslate nohighlight">\(x_h^{k+1} = g\left(x_h^{k}\right)\)</span> to solve the system of equations.
The goal of the fixed point scheme is to find some input <span class="math notranslate nohighlight">\(x\)</span> such that <span class="math notranslate nohighlight">\(g(x) = x\)</span>.
In our case, we want the exact solution <span class="math notranslate nohighlight">\(x_h\)</span> to be a fixed point of our iteration.
We observe that the defect of the exact solution is zero. Thus one might try to increment the old iterate <span class="math notranslate nohighlight">\(x_h\)</span>
by some multiple of the defect. This is called the Richardson method. However, the Richardson method is rarely used in practice.
Instead we will work with the more general fixed point scheme</p>
<div class="math notranslate nohighlight">
\[x_h^{k+1} = x_h^{k} + \omega C^{-1}\left(b_h - A_h x_h^{k} \right)\]</div>
<p>where <span class="math notranslate nohighlight">\(C \in \mathbb{R}^{n_{DoFs} \times n_{DoFs}}\)</span>. Here the type of method depends on the matrix <span class="math notranslate nohighlight">\(C\)</span>, e.g.
<span class="math notranslate nohighlight">\(C = I\)</span> is the Richardson method. In our code, we implemented</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(C = D\)</span> which is the <span class="math notranslate nohighlight">\(\omega\)</span>-<span class="blue">Jacobi</span> method,</p></li>
<li><p><span class="math notranslate nohighlight">\(C = \left( D + L \right)\)</span> which is the  <span class="blue">Forward Gauss-Seidel</span> method for <span class="math notranslate nohighlight">\(\omega = 1\)</span>,</p></li>
<li><p><span class="math notranslate nohighlight">\(C = \left( D + U \right)\)</span> which is the  <span class="blue">Backward Gauss-Seidel</span> method for <span class="math notranslate nohighlight">\(\omega = 1\)</span>.</p></li>
</ul>
<p>In these definitions, we used the decomposition  <span class="math notranslate nohighlight">\(A_h = L + D + U\)</span>, where <span class="math notranslate nohighlight">\(L\)</span> has only nonzero entries below the diagonal (strictly lower triangular matrix),
<span class="math notranslate nohighlight">\(D\)</span> has only nonzero entries on the diagonal (diagonal matrix) and <span class="math notranslate nohighlight">\(U\)</span> has only nonzero entries above the diagonal (strictly upper triangular matrix).</p>
<p>Note that we need to compute the inverse matrix <span class="math notranslate nohighlight">\(C^{-1}\)</span>. This can be easily done for <span class="math notranslate nohighlight">\(\omega\)</span>-Jacobi,
since we just invert the diagonal. It wouldn’t be efficient to invert <span class="math notranslate nohighlight">\(\left( D + L \right)\)</span> or <span class="math notranslate nohighlight">\(\left( D + U \right)\)</span> directly.
Hence we use the formula</p>
<div class="math notranslate nohighlight">
\[x_i^k = \frac{1}{a_{ii}}\left( b_i - \sum_{j &lt; i}a_{ij}x_j^k - \sum_{j &gt; i}a_{ij}x_j^{k-1} \right) \quad \text{for } i = 1, \dots n_{DoFs}\]</div>
<p>for Forward Gauss-Seidel and the formula</p>
<div class="math notranslate nohighlight">
\[x_i^k = \frac{1}{a_{ii}}\left( b_i - \sum_{j &lt; i}a_{ij}x_j^{k-1} - \sum_{j &gt; i}a_{ij}x_j^{k} \right) \quad \text{for } i = n_{DoFs},  \dots, 1\]</div>
<p>for Backward Gauss-Seidel. In these formulas, we used the notation <span class="math notranslate nohighlight">\(a_{ij} := (A_h)_{ij}\)</span>, <span class="math notranslate nohighlight">\(b_{i} := (b_h)_{i}\)</span> and <span class="math notranslate nohighlight">\(x_i^{k} := (x_h^{k})_i\)</span>.</p>
<p>Which of these iterative methods should be used in numerical computations? It depends!
<span class="math notranslate nohighlight">\(\omega\)</span>-Jacobi has the benefit of being fast, since it can be parallelized.
Nevertheless, it needs more iterations to converge than Gauss-Seidel and one needs to choose a good value for <span class="math notranslate nohighlight">\(\omega\)</span> before computation.
Although the Gauss-Seidel methods converge in less iterations, they need longer for the computation, since the for loops need to be executed sequentially.</p>
<p>In the next few sections, we will show how <span class="math notranslate nohighlight">\(\omega\)</span>-Jacobi and Gauss-Seidel can be used in the multigrid method,
resulting in a fast solver for the linear equation system derived from a discrete weak form of the convection-diffusion equation.</p>
</div>
<div class="section" id="grid-setup">
<h2>Grid Setup<a class="headerlink" href="#grid-setup" title="Permalink to this headline">¶</a></h2>
<p>To transform the weak form of our problem into a linear equation system,
we first need to discretize our domain. For that purpose, we create an initial triangulation of the domain,
i.e. we divide <span class="math notranslate nohighlight">\(\Omega\)</span> into a set of triangles. We call this triangulation the <span class="blue">coarse grid</span> and denote it as <span class="math notranslate nohighlight">\(\mathbb{T}_0\)</span>.
The grid consists of objects of type <code class="code docutils literal notranslate"><span class="pre">Node</span></code>, <code class="code docutils literal notranslate"><span class="pre">Edge</span></code> and <code class="code docutils literal notranslate"><span class="pre">Triangle</span></code>.</p>
<div class="figure align-center">
<img alt="coarse_grid" src="_images/CoarseGrid.svg" /></div>
<p class="centered">
<strong>Figure 3: Coarse grid (<span class="math notranslate nohighlight">\(\mathbb{T}_0\)</span>)</strong></p><p>For the multigrid method, we need a sequence of such grids.
In this work, we restrict our analysis to uniformly refined meshes.
How can we create these refined meshes? We have to loop over all triangles of the grid
and then refine them.</p>
<div class="figure align-center">
<img alt="triangle_refinement" src="_images/triangle_refinement.svg" /></div>
<p class="centered">
<strong>Figure 4: Refining a triangle</strong></p><p>To refine a triangle one simply needs to bisect all of its edges and draw a new triangle out of these three new nodes.
As shown in figure 4, through the refinement process a triangle is being divided
into four smaller triangles. Each <code class="code docutils literal notranslate"><span class="pre">Node</span></code> object needs to know its parent nodes.
The parents are two end nodes of the edge that has been bisected, e.g. node 1 and node 2 are the parents of node 4.
In the literature [1] these relationships are being stored in a father-son list.
This is not needed in our case, due to Object Oriented Programming (OOP).</p>
<p>Having refined all triangles of the coarse grid, we get a new triangulation <span class="math notranslate nohighlight">\(\mathbb{T}_1\)</span>,
which is called the grid on level 1. The <span class="blue">level</span> of a grid indicates how often we need to (globally)
refine the coarse grid to construct that grid.</p>
<div class="figure align-center">
<img alt="grid_level_1" src="_images/GridLevel1.svg" /></div>
<p class="centered">
<strong>Figure 5: Grid on level 1 (<span class="math notranslate nohighlight">\(\mathbb{T}_1\)</span>)</strong></p><p>We continue the process of refining the grid, until we end up with a grid, which has enough nodes
to ensure that a sufficiently good approximation to the exact solution can be computed.</p>
<div class="figure align-center">
<img alt="grid_level_2" src="_images/GridLevel2.svg" /></div>
<p class="centered">
<strong>Figure 6: Grid on level 2 (<span class="math notranslate nohighlight">\(\mathbb{T}_2\)</span>)</strong></p><p>The grid on the highest level, in this case <span class="math notranslate nohighlight">\(\mathbb{T}_2\)</span> or more generally <span class="math notranslate nohighlight">\(\mathbb{T}_L\)</span>, is called the finest grid
and will be used to assemble the system matrix.</p>
<p>Using the Finite Element Method, we can discretize the weak form of our PDE on each level grid
with linear finite elements. For each level <span class="math notranslate nohighlight">\(0 \leq l \leq L\)</span>, we get a linear equation system</p>
<div class="math notranslate nohighlight">
\[A_l x_l = b_l \text{  with  } A_l \in \mathbb{R}^{n_l \times n_l}, x_l, b_l \in \mathbb{R}^{n_l},\]</div>
<p>where <span class="math notranslate nohighlight">\(n_l\)</span> is the number of degrees of freedom (DoFs), which in our case corresponds to the number of nodes in the grid.
Note that the discrete function spaces <span class="math notranslate nohighlight">\(\left( V_l \right)_{l=0}^L\)</span> from the FEM are conforming finite element spaces,
i.e. <span class="math notranslate nohighlight">\(V_0 \subset V_1 \subset \cdots \subset V_L\)</span>. If this wasn’t the case, the grid transfer operations, which will be introduced shortly, would need to be modified.</p>
</div>
<div class="section" id="two-grid-algorithm">
<h2>Two-grid algorithm<a class="headerlink" href="#two-grid-algorithm" title="Permalink to this headline">¶</a></h2>
<p>To understand the multigrid algorithm we start by looking at the case where we only have two grids <span class="math notranslate nohighlight">\(\mathbb{T}_{l}\)</span> and <span class="math notranslate nohighlight">\(\mathbb{T}_{l+1}\)</span>.
The mulitgrid algorithm is then only a recursive application of the two grid version.</p>
<div class="admonition-two-grid-algorithm admonition">
<p class="admonition-title">Two-grid algorithm</p>
<p>Let <span class="math notranslate nohighlight">\(A_h x_h = b_h\)</span> and <span class="math notranslate nohighlight">\(A_{2h} x_{2h} = b_{2h}\)</span> with <span class="math notranslate nohighlight">\(A_h \in \mathbb{R}^{n \times n}\)</span>,
<span class="math notranslate nohighlight">\(A_{2h} \in \mathbb{R}^{m \times m}\)</span> and <span class="math notranslate nohighlight">\(m &lt; n\)</span>
denote the linear equation systems from the grids <span class="math notranslate nohighlight">\(\mathbb{T}_{l+1}\)</span> and <span class="math notranslate nohighlight">\(\mathbb{T}_{l}\)</span>.
Let the k-th iterate <span class="math notranslate nohighlight">\(x_h^k\)</span> on the finer grid be given.</p>
<div class="figure align-center">
<img alt="tgm" src="_images/tgm_trans.png" />
</div>
</div>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>In most cases we want the two-grid method to be a symmetric iteration.
Therefore we need <span class="math notranslate nohighlight">\(\nu := \nu_1 = \nu_2\)</span> and <span class="math notranslate nohighlight">\(S := S_1 = S_2^\ast\)</span> [4],
e.g. choose <span class="math notranslate nohighlight">\(S_1\)</span> as forward Gauss-Seidel and <span class="math notranslate nohighlight">\(S_2\)</span> as backward Gauss-Seidel.
Alternatively we have also implemented the <span class="math notranslate nohighlight">\(\omega\)</span>-Jacobi method which can be used for pre- and post-smoothing.
Furthermore <span class="math notranslate nohighlight">\(A_{2h}^{-1}d_{2h}\)</span> is not feasible to compute with a direct solver
if <span class="math notranslate nohighlight">\(A_{2h}\)</span> is too large, which is often the case.
Thus <span class="math notranslate nohighlight">\(A_{2h}^{-1}d_{2h}\)</span> can be understood as solving the linear equation system and can be done for example by another two-grid method. This recursion then produces the multigrid algorithm.</p>
</div>
</div>
<div class="section" id="multigrid-algorithm">
<h2>Multigrid algorithm<a class="headerlink" href="#multigrid-algorithm" title="Permalink to this headline">¶</a></h2>
<div class="admonition-multigrid-algorithm admonition">
<p class="admonition-title">Multigrid algorithm</p>
<p>Let <span class="math notranslate nohighlight">\(A_L x_L = b_L\)</span> denote the problem on the finest grid and <span class="math notranslate nohighlight">\(A_l x_l = b_l\)</span>
the problems on the coarser grids for <span class="math notranslate nohighlight">\(0 \leq l \leq L-1\)</span>.
Let <span class="math notranslate nohighlight">\(\nu\)</span> denote the number of pre- and post-smoothing steps.
Let the k-th iterate <span class="math notranslate nohighlight">\(x_l^k\)</span> on the l-th level be given.</p>
<div class="figure align-center">
<img alt="mgm" src="_images/mgm_trans.png" />
</div>
</div>
<p>The parameter <span class="math notranslate nohighlight">\(\mu \in \mathbb{N}^+\)</span> determines the <span class="blue">cycle</span> of the multigrid iteration.
For <span class="math notranslate nohighlight">\(\mu = 1\)</span> we get the V-cycle</p>
<div class="figure">
<p><img src="_images/tikz-bf0cb5d157710f5536fe0d52b59615e9e5f4431c.png" alt="\node (A) at (0,3) [circle, minimum size=2mm, inner sep=0pt,draw] {};
\node (B) at (1,2) [circle, minimum size=2mm, inner sep=0pt,draw] {};
\node (C) at (2,1) [circle, minimum size=2mm, inner sep=0pt,draw] {};
\node (D) at (3,0) [circle, minimum size=2mm, inner sep=0pt,fill = black, draw] {};
\node (E) at (4,1) [circle, minimum size=2mm, inner sep=0pt,draw] {};
\node (F) at (5,2) [circle, minimum size=2mm, inner sep=0pt,draw] {};
\node (G) at (6,3) [circle, minimum size=2mm, inner sep=0pt,draw] {};

\node [color=black] at (-1,3) {\tiny $l = 3$};
\node [color=black] at (-1,2) {\tiny $l = 2$};
\node [color=black] at (-1,1) {\tiny $l = 1$};
\node [color=black] at (-1,0) {\tiny $l = 0$};

{\color{blue}
\draw[-&gt;] (A) to (B);
\draw[-&gt;] (B) to (C);
\draw[-&gt;] (C) to (D);
}

{\color{black!40!green}
\draw[-&gt;] (D) to (E);
\draw[-&gt;] (E) to (F);
\draw[-&gt;] (F) to (G);
}" /></p>
</div><p class="centered">
<strong>Figure 7: V-cycle</strong></p><p>and for <span class="math notranslate nohighlight">\(\mu = 2\)</span> we get the W-cycle.</p>
<div class="figure">
<p><img src="_images/tikz-362301dbc83d59069c61878e8ce3341f1b2ddb32.png" alt="\node (A) at (0,3) [circle, minimum size=2mm, inner sep=0pt,draw] {};
\node (B) at (1,2) [circle, minimum size=2mm, inner sep=0pt,draw] {};
\node (C) at (2,1) [circle, minimum size=2mm, inner sep=0pt,draw] {};
\node (D) at (3,0) [circle, minimum size=2mm, inner sep=0pt,fill = black, draw] {};
\node (E) at (4,1) [circle, minimum size=2mm, inner sep=0pt,draw] {};
\node (F) at (5,0) [circle, minimum size=2mm, inner sep=0pt,fill = black, draw] {};
\node (G) at (6,1) [circle, minimum size=2mm, inner sep=0pt,draw] {};
\node (H) at (7,2) [circle, minimum size=2mm, inner sep=0pt,draw] {};
\node (I) at (8,1) [circle, minimum size=2mm, inner sep=0pt,draw] {};
\node (J) at (9,0) [circle, minimum size=2mm, inner sep=0pt,fill = black, draw] {};
\node (K) at (10,1) [circle, minimum size=2mm, inner sep=0pt,draw] {};
\node (L) at (11,0) [circle, minimum size=2mm, inner sep=0pt,fill = black, draw] {};
\node (M) at (12,1) [circle, minimum size=2mm, inner sep=0pt,draw] {};
\node (N) at (13,2) [circle, minimum size=2mm, inner sep=0pt,draw] {};
\node (O) at (14,3) [circle, minimum size=2mm, inner sep=0pt,draw] {};

\node [color=black] at (-1,3) {\scriptsize $l = 3$};
\node [color=black] at (-1,2) {\scriptsize $l = 2$};
\node [color=black] at (-1,1) {\scriptsize $l = 1$};
\node [color=black] at (-1,0) {\scriptsize $l = 0$};

{\color{blue}
\draw[-&gt;] (A) to (B);
\draw[-&gt;] (B) to (C);
\draw[-&gt;] (C) to (D);
}

{\color{black!40!green}
\draw[-&gt;] (D) to (E);
}
{\color{blue}
\draw[-&gt;] (E) to (F);
}
{\color{black!40!green}
\draw[-&gt;] (F) to (G);
\draw[-&gt;] (G) to (H);
}
{\color{blue}
\draw[-&gt;] (H) to (I);
\draw[-&gt;] (I) to (J);
}
{\color{black!40!green}
\draw[-&gt;] (J) to (K);
}
{\color{blue}
\draw[-&gt;] (K) to (L);
}
{\color{black!40!green}
\draw[-&gt;] (L) to (M);
\draw[-&gt;] (M) to (N);
\draw[-&gt;] (N) to (O);
}" /></p>
</div><p class="centered">
<strong>Figure 8: W-cycle</strong></p><p>In the figures of these schemes, white circles stand for <span class="math notranslate nohighlight">\(\nu\)</span> steps of an iterative solver,
black circles represent a direct solver, blue arrows illustrate a restriction and green arrows illustrate a prolongation.</p>
</div>
<div class="section" id="grid-transfer">
<h2>Grid transfer<a class="headerlink" href="#grid-transfer" title="Permalink to this headline">¶</a></h2>
<p>As we have seen in the previous sections, the multigrid algorithm requires the ability to
prolongate vectors from <span class="math notranslate nohighlight">\(\mathbb{R}^{n_{l}}\)</span> to <span class="math notranslate nohighlight">\(\mathbb{R}^{n_{l-1}}\)</span>.
We will only show how the grid transfer operations work for conforming finite elements.
For information on how to deal with non-conforming finite element spaces, please refer to [3].
Let <span class="math notranslate nohighlight">\(\left\{\varphi_1^l, \dots, \varphi_{n_{l}}^l\right\}\)</span> and
<span class="math notranslate nohighlight">\(\left\{\varphi_1^{l-1}, \dots, \varphi_{n_{l-1}}^{l-1}\right\}\)</span> be some given bases of
<span class="math notranslate nohighlight">\(V^l\)</span> and <span class="math notranslate nohighlight">\(V^{l-1}\)</span>.
Due to the conformity of the finite element spaces,
<span class="math notranslate nohighlight">\(V^{l-1} \subset V^l\)</span> holds and there exists a matrix <span class="math notranslate nohighlight">\(I^{l-1}_l \in \mathbb{R}^{n_{-1} \times n_l}\)</span>
such that</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{pmatrix}
\varphi_1^{l-1} \\
\vdots \\
\varphi_{n_{l-1}}^{l-1}
\end{pmatrix} = I^{l-1}_l
\begin{pmatrix}
\varphi_1^{l} \\
\vdots \\
\varphi_{n_{l}}^{l}
\end{pmatrix}.\end{split}\]</div>
<p>The matrix <span class="math notranslate nohighlight">\(I^{l-1}_l\)</span> is called the <span class="blue">restriction matrix</span> and its transpose <span class="math notranslate nohighlight">\(I^{l}_{l-1} = \left(I^{l-1}_l\right)^T\)</span> is called the <span class="blue">prolongation matrix.</span>
These matrices are dependent on the finite elements that are being used and on the way that the grids have been refined.
They have only very few non-zero entries and thus are stored as sparse matrices.
Furthermore, they also have a significant impact on the rate of convergence of the multigrid algorithm [3]].
Additionally, for linear partial differential equations the identity</p>
<div class="math notranslate nohighlight">
\[A_{l-1} = I^{l}_{l-1} A_l I^{l-1}_l\]</div>
<p>is fulfilled. Before taking a look at the actual implementation in our code,
it is helpful to a see how the the grid transfer works for one dimensional linear finite elements.</p>
<div class="admonition-grid-transfer-in-1d admonition">
<p class="admonition-title">Grid transfer in 1D</p>
<div class="figure align-center">
<img alt="grid_transfer" src="_images/grid_transfer.png" />
</div>
<p class="centered">
<strong>Figure 9: Basis functions on the first two levels</strong></p><p>It holds</p>
<div class="math notranslate nohighlight">
\[\begin{split}\varphi_1^0 &amp;= \varphi_1^1 + \frac{1}{2}\varphi_3^1, \\
\varphi_2^0 &amp;= \varphi_2^1 + \frac{1}{2}\varphi_3^1.\end{split}\]</div>
<p>Consequently the restriction matrix reads</p>
<div class="math notranslate nohighlight">
\[\begin{split}I_1^0 =
\begin{bmatrix}
1 &amp; &amp; \frac{1}{2} \\
&amp; 1 &amp; \frac{1}{2}
\end{bmatrix}.\end{split}\]</div>
</div>
<p>We decided to follow these rules to create the interpolation matrix <span class="math notranslate nohighlight">\(I_{l-1}^l\)</span>:</p>
<ul class="simple">
<li><p>if the i.th node already exists on level <span class="math notranslate nohighlight">\({l-1}\)</span>, then <span class="math notranslate nohighlight">\(\left(I_{l-1}^l\right)_{i,i} = 1\)</span></p></li>
<li><p>else get the indices of the parents of the i.th node, then <span class="math notranslate nohighlight">\(\left(I_{l-1}^l\right)_{i,\text{parent}_1} = \frac{1}{2}\)</span> and <span class="math notranslate nohighlight">\(\left(I_{l-1}^l\right)_{i,\text{parent}_2} = \frac{1}{2}\)</span></p></li>
</ul>
<p>The rest of this matrix is filled with zeros. Doing this for <span class="math notranslate nohighlight">\({l=1}\)</span> yields the prolongation matrix</p>
<div class="math notranslate nohighlight">
\[\begin{split}I_0^1 =
\begin{bmatrix}
1 &amp; &amp; &amp; &amp; &amp; &amp; &amp;  \\
&amp; 1 &amp; &amp; &amp; &amp; &amp; &amp;  \\
&amp; &amp; 1 &amp; &amp; &amp; &amp; &amp;  \\
&amp; &amp; &amp; 1 &amp; &amp; &amp; &amp;  \\
&amp; &amp; &amp; &amp; 1 &amp; &amp; &amp;  \\
&amp; &amp; &amp; &amp; &amp; 1 &amp; &amp;  \\
&amp; &amp; &amp; &amp; &amp; &amp; 1 &amp;  \\
&amp; &amp; &amp; &amp; &amp; &amp; &amp; 1  \\
\frac{1}{2}&amp;\frac{1}{2} &amp; &amp; &amp; &amp; &amp; &amp;  \\
&amp; \frac{1}{2}&amp;\frac{1}{2} &amp; &amp; &amp; &amp; &amp;  \\
\frac{1}{2}&amp; &amp; &amp;\frac{1}{2} &amp; &amp; &amp; &amp; \\
&amp; \frac{1}{2}&amp; &amp; &amp; \frac{1}{2}&amp; &amp; &amp; \\
&amp; &amp; &amp;\frac{1}{2} &amp;\frac{1}{2} &amp; &amp; &amp; \\
&amp; &amp;\frac{1}{2} &amp; &amp; &amp;\frac{1}{2} &amp; &amp; \\
&amp; &amp; &amp; &amp;\frac{1}{2} &amp;\frac{1}{2} &amp; &amp; \\
&amp; &amp; &amp; \frac{1}{2}&amp; &amp; &amp; \frac{1}{2}&amp;  \\
&amp; &amp; &amp; &amp; \frac{1}{2}&amp; &amp; &amp; \frac{1}{2}\\
&amp; &amp; &amp; &amp; &amp; &amp; \frac{1}{2}&amp; \frac{1}{2}\\
\frac{1}{2}&amp; &amp; &amp; &amp;\frac{1}{2} &amp; &amp; &amp; \\
&amp; &amp; &amp;\frac{1}{2} &amp; &amp; &amp; &amp; \frac{1}{2} \\
&amp;\frac{1}{2} &amp; &amp; &amp; &amp; \frac{1}{2}&amp; &amp;  \\
\end{bmatrix}.\end{split}\]</div>
<p>For our kind of prolongation matrix, the restriction matrix is given by</p>
<div class="math notranslate nohighlight">
\[I_l^{l-1} = \frac{1}{4}\left( I_{l-1}^l \right)^T.\]</div>
<p>At this point, we should also mention how the boundary conditions can be applied
in the multigrid algorithm. The start vector of this method should be the zero vector on which the Dirichlet boundary conditions should be applied.
Note that Dirichlet boundary conditions need to be applied to the output vectors of the prolongation and restriction,
but here <span class="red">all Dirichlet boundary conditions are set to be homogeneous</span>.</p>
</div>
<div class="section" id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<ol class="arabic simple">
<li><p>Sven Beuchler. <em>Lecture notes in ‘Multigrid and domain decomposition.’</em> April 2020.</p></li>
<li><p>Thomas Wick. <em>Numerical Methods for Partial Differential Equations.</em> 2020. URL: <a class="reference external" href="https://doi.org/10.15488/9248">https://doi.org/10.15488/9248</a>.</p></li>
<li><p>Dietrich Braess. <em>Finite Elemente.</em> Springer Berlin Heidelberg, 2013. DOI: 10.1007/978-3-642-34797-9. URL: <a class="reference external" href="https://doi.org/10.1007%2F978-3-642-34797-9">https://doi.org/10.1007%2F978-3-642-34797-9</a>.</p></li>
<li><p>Chao Chen. “Geometric multigrid for eddy current problems”. PhD thesis. 2012.</p></li>
<li><p>Julian Roth. “Geometric Multigrid Methods for Maxwell’s Equations”. Bachelor thesis. 2020.</p></li>
<li><p>Thomas Richter and Thomas Wick. Einführung in die numerische Mathematik - Begriffe, Konzepte und zahlreiche Anwendungsbeispiele. Springer, 2017.</p></li>
</ol>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="Multigrid.html" class="btn btn-neutral float-right" title="Results of Multigrid for Convection Diffusion" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral float-left" title="Welcome to Multigrid’s documentation!" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Julian Roth, Max Schröder

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>