

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Basics of Geometric Multigrid &mdash; Multigrid 1.0.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Results on Benchmark Problem" href="results.html" />
    <link rel="prev" title="Welcome to Multigrid’s documentation!" href="index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Multigrid
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Table of Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Basics of Geometric Multigrid</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#problem-setup">Problem setup</a></li>
<li class="toctree-l2"><a class="reference internal" href="#finite-element-method">Finite Element Method</a></li>
<li class="toctree-l2"><a class="reference internal" href="#grid-setup">Grid Setup</a></li>
<li class="toctree-l2"><a class="reference internal" href="#two-grid-algorithm">Two-grid algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="#multigrid-algorithm">Multigrid algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="#grid-transfer">Grid transfer</a></li>
<li class="toctree-l2"><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="results.html">Results on Benchmark Problem</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Multigrid</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Basics of Geometric Multigrid</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/basics.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="basics-of-geometric-multigrid">
<h1>Basics of Geometric Multigrid<a class="headerlink" href="#basics-of-geometric-multigrid" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>In the following, we are describing the geometric multigrid method,
which for certain problems yields an iterative solver
with optimal time complexity, i.e. the solver returns a solution to a PDE in
<span class="math notranslate nohighlight">\(O(n_{\text{DoFs}})\)</span> arithmetic operations. We will show that this can also
be achieved for some convection-diffusion equations on uniformly refined triangular
meshes, when discretizing with linear finite elements.</p>
</div>
<div class="section" id="problem-setup">
<h2>Problem setup<a class="headerlink" href="#problem-setup" title="Permalink to this headline">¶</a></h2>
<p>Let <span class="math notranslate nohighlight">\(\Omega := (-1,1)^2 \setminus (0,1)^2\)</span> be an L-shaped domain. We decompose the boundary of this domain <span class="math notranslate nohighlight">\(\partial\Omega\)</span> into the Neumann boundary <span class="math notranslate nohighlight">\(\Gamma_N := (0,1) \times \{0\} \cup \{0\} \times (0,1)\)</span>
and the Dirichlet boundary <span class="math notranslate nohighlight">\(\Gamma_D := \partial\Omega \setminus \Gamma_N\)</span>.</p>
<p>Next, we define the ansatz and test function space <span class="math notranslate nohighlight">\(V := \left\{ u \in H^1(\Omega)\mid u = 0 \text{ on } \Gamma_D \right\}\)</span>,
where</p>
<div class="math notranslate nohighlight">
\[H^1(\Omega) := W^{1,2}(\Omega) := \left\{ u \in L^2(\Omega) \mid \nabla u \in L^2( \Omega ) \right\}\]</div>
<p>is the Sobolev space containing the weakly differentiable functions
in <span class="math notranslate nohighlight">\(\Omega\)</span>. Note that we haven’t explicitly prescribed any boundary conditions on <span class="math notranslate nohighlight">\(\Gamma_N\)</span> in the function space,
since the homogeneous Neumann boundary conditions come up naturally when deriving the variational form of the problem.
Further, we need a right hand side function</p>
<div class="math notranslate nohighlight">
\[\begin{split}f(x) :=
\begin{cases}
   -1 &amp; \text{for } x \in (-1,0) \times (0,1) \\
   0 &amp; \text{for } x \in (-1,0) \times (-1,0) \\
   1 &amp; \text{for } x \in (0,1) \times (-1,0) \\
\end{cases}.\end{split}\]</div>
<div class="figure align-center" id="id1">
<img alt="domain" src="_images/domain.svg" /><p class="caption"><span class="caption-text">Figure 1: Domain <span class="math notranslate nohighlight">\(\Omega\)</span></span><a class="headerlink" href="#id1" title="Permalink to this image">¶</a></p>
</div>
<p>Using the parameters <span class="math notranslate nohighlight">\(a = 1\)</span> and <span class="math notranslate nohighlight">\(c = 0\)</span> in <span class="math notranslate nohighlight">\(\Omega\)</span>, we can now
formulate the strong form of our convection diffusion equation:</p>
<div class="admonition-strong-form admonition">
<p class="admonition-title">Strong form</p>
<p>Find <span class="math notranslate nohighlight">\(u: \Omega \rightarrow \mathbb{R}\)</span> such that</p>
<div class="math notranslate nohighlight">
\[\begin{split}-\nabla \cdot \left( a \nabla u\right) + c u &amp;= f \quad \text{in } \Omega \qquad (1)\\
u &amp;= 0 \quad \text{on } \Gamma_D \\
\partial_n u &amp;= 0 \quad \text{on } \Gamma_N\end{split}\]</div>
</div>
<p>In the above formulation, we used the notation <span class="math notranslate nohighlight">\(\partial n := \nabla \cdot n\)</span>.
To be able to solve this problem, we need to convert it into its integral form.
Therefore we multiply (1) from the right with a test function <span class="math notranslate nohighlight">\(v \in V\)</span> and integrate over <span class="math notranslate nohighlight">\(\Omega\)</span>.</p>
<div class="math notranslate nohighlight">
\[-\int_{\Omega} \left(\nabla \cdot \left( a \nabla u\right)\right) \cdot v\ dx
+ \int_{\Omega} c u \cdot v\ dx
= \int_{\Omega} f \cdot v\ dx \quad \forall v \in V\]</div>
<p>Now integration of parts can be applied to the first integral and we use the fact that <span class="math notranslate nohighlight">\(\partial \Omega = \Gamma_D\ \dot\cup\ \Gamma_N\)</span>.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\int_{\Omega} a \nabla u \cdot \nabla v\ dx
-\int_{\Gamma_D} a \partial_n u \cdot v\ ds
-\int_{\Gamma_N} a \partial_n u \cdot v\ ds \\
+ \int_{\Omega} c u \cdot v\ dx
= \int_{\Omega} f \cdot v\ dx \quad \forall v \in V\end{split}\]</div>
<p>Note that the integrals over the boundaries <span class="math notranslate nohighlight">\(\Gamma_D\)</span> and <span class="math notranslate nohighlight">\(\Gamma_N\)</span> vanish,
since <span class="math notranslate nohighlight">\(\partial_n u = 0\)</span> on <span class="math notranslate nohighlight">\(\Gamma_N\)</span> and, due to <span class="math notranslate nohighlight">\(v \in V\)</span>, <span class="math notranslate nohighlight">\(u = 0\)</span> on <span class="math notranslate nohighlight">\(\Gamma_D\)</span>.
Thus we have derived the following integral problem of our problem,
which is often referred to as the weak or variational form in the literature.</p>
<div class="admonition-weak-form admonition">
<p class="admonition-title">Weak form</p>
<p>Find <span class="math notranslate nohighlight">\(u \in V\)</span> such that</p>
<div class="math notranslate nohighlight">
\[a(u,v) = l(v) \quad \forall v \in V\]</div>
<p>where <span class="math notranslate nohighlight">\(a: V \times V \rightarrow \mathbb{R}\)</span> is the bilinear form defined as</p>
<div class="math notranslate nohighlight">
\[a(u,v) := \int_{\Omega} a \nabla u \cdot \nabla v\ dx + \int_{\Omega} c u \cdot v\ dx\]</div>
<p>and the right hand side <span class="math notranslate nohighlight">\(l: V \rightarrow \mathbb{R}\)</span> is a linear form defined as</p>
<div class="math notranslate nohighlight">
\[l(v) := \int_{\Omega} f \cdot v\ dx\]</div>
</div>
<p>Furthermore using the fundamental lemma of calculus of variations, it can be shown that the strong and the weak form
are equivalent. Hence it suffices to solve the weak form of the problem.</p>
</div>
<div class="section" id="finite-element-method">
<h2>Finite Element Method<a class="headerlink" href="#finite-element-method" title="Permalink to this headline">¶</a></h2>
<p>TODO !!!</p>
</div>
<div class="section" id="grid-setup">
<h2>Grid Setup<a class="headerlink" href="#grid-setup" title="Permalink to this headline">¶</a></h2>
<p>To transform the weak form of our problem into a linear equation system,
we first need to discretize our domain. For that purpose, we create an initial triangulation of the domain,
i.e. we divide <span class="math notranslate nohighlight">\(\Omega\)</span> into a set of triangles. We call this triangulation the coarse grid and denote it as <span class="math notranslate nohighlight">\(\mathbb{T}_0\)</span>.
The grid consists of objects of type <code class="code docutils literal notranslate"><span class="pre">Node</span></code>, <code class="code docutils literal notranslate"><span class="pre">Edge</span></code> and <code class="code docutils literal notranslate"><span class="pre">Triangle</span></code>.</p>
<div class="figure align-center" id="id2">
<img alt="coarse_grid" src="_images/CoarseGrid.svg" /><p class="caption"><span class="caption-text">Figure 2: Coarse grid (<span class="math notranslate nohighlight">\(\mathbb{T}_0\)</span>)</span><a class="headerlink" href="#id2" title="Permalink to this image">¶</a></p>
</div>
<p>For the multigrid method, we need a sequence of such grids.
In this work, we restrict our analysis to uniformly refined meshes.
How can we create these refined meshes? We have to loop over all triangles of the grid
and then refine them.</p>
<div class="figure align-center" id="id3">
<img alt="triangle_refinement" src="_images/triangle_refinement.svg" /><p class="caption"><span class="caption-text">Figure 3: Refining a triangle</span><a class="headerlink" href="#id3" title="Permalink to this image">¶</a></p>
</div>
<p>To refine a triangle one simply needs to bisect all of its edges and draw a new triangle out of these three new nodes.
As shown in figure 3, through the refinement process a triangle is being divided
into four smaller triangles. Each <code class="code docutils literal notranslate"><span class="pre">Node</span></code> object needs to know its parent nodes.
The parents are two end nodes of the edge that has been bisected, e.g. node 1 and node 2 are the parents of node 4.
In the literature [1] these relationships are being stored in a father son list.
This is not needed in our case, due to Object Oriented Programming (OOP).</p>
<p>Having refined all triangles of the coarse grid, we get a new triangulation <span class="math notranslate nohighlight">\(\mathbb{T}_1\)</span>,
which is called the grid on level 1. The level of a grid indicates, how often we need to (globally)
refine the coarse grid to construct that grid.</p>
<div class="figure align-center" id="id4">
<img alt="grid_level_1" src="_images/GridLevel1.svg" /><p class="caption"><span class="caption-text">Figure 4: Grid on level 1 (<span class="math notranslate nohighlight">\(\mathbb{T}_1\)</span>)</span><a class="headerlink" href="#id4" title="Permalink to this image">¶</a></p>
</div>
<p>We continue the process of refining the grid, until we end up with a grid, which has enough nodes
to ensure that a sufficiently good approximation to the exact solution can be computed.</p>
<div class="figure align-center" id="id5">
<img alt="grid_level_2" src="_images/GridLevel2.svg" /><p class="caption"><span class="caption-text">Figure 5: Grid on level 2 (<span class="math notranslate nohighlight">\(\mathbb{T}_2\)</span>)</span><a class="headerlink" href="#id5" title="Permalink to this image">¶</a></p>
</div>
<p>The grid on the highest level, in this case <span class="math notranslate nohighlight">\(\mathbb{T}_2\)</span> or more generally <span class="math notranslate nohighlight">\(\mathbb{T}_L\)</span>, is called the finest grid
and will be used to assemble the system matrix.</p>
<p>Using the Finite Element Method, we can discretize the weak form of our PDE on each level grid
with linear finite elements. For each level <span class="math notranslate nohighlight">\(0 \leq l \leq L\)</span>, we get a linear equation system</p>
<div class="math notranslate nohighlight">
\[A_l x_l = b_l \text{  with  } A_l \in \mathbb{R}^{n_l \times n_l}, x_l, b_l \in \mathbb{R}^{n_l},\]</div>
<p>where <span class="math notranslate nohighlight">\(n_l\)</span> is the number of degrees of freedom (DoFs), which in our case corresponds to the number of nodes in the grid.
Note that the discrete function spaces <span class="math notranslate nohighlight">\(\left( V_l \right)_{l=0}^L\)</span> from the FEM are conforming finite element spaces,
i.e. <span class="math notranslate nohighlight">\(V_0 \subset V_1 \subset \cdots \subset V_L\)</span>. If this wasn’t the case, the grid transfer operations, which will be introduced shortly, would need to be modified.</p>
</div>
<div class="section" id="two-grid-algorithm">
<h2>Two-grid algorithm<a class="headerlink" href="#two-grid-algorithm" title="Permalink to this headline">¶</a></h2>
<p>To understand the multigrid algorithm we start by looking at the case where we only have two grids <span class="math notranslate nohighlight">\(\mathbb{T}_{l}\)</span> and <span class="math notranslate nohighlight">\(\mathbb{T}_{l+1}\)</span>.
The mulitgrid algorithm is then only a recursive application of the two grid version.</p>
<div class="admonition-two-grid-algorithm admonition">
<p class="admonition-title">Two-grid algorithm</p>
<p>Let <span class="math notranslate nohighlight">\(A_h x_h = b_h\)</span> and <span class="math notranslate nohighlight">\(A_{2h} x_{2h} = b_{2h}\)</span> with <span class="math notranslate nohighlight">\(A_h \in \mathbb{R}^{n \times n}\)</span>,
<span class="math notranslate nohighlight">\(A_{2h} \in \mathbb{R}^{m \times m}\)</span> and <span class="math notranslate nohighlight">\(m &lt; n\)</span>
denote the linear equation systems from the grids <span class="math notranslate nohighlight">\(\mathbb{T}_{l+1}\)</span> and <span class="math notranslate nohighlight">\(\mathbb{T}_{l}\)</span>.
Let the k-th iterate <span class="math notranslate nohighlight">\(x_h^k\)</span> on the finer grid be given.</p>
<div class="math notranslate nohighlight">
\[\begin{split}&amp;\text{def TGM(}x_h^k\text{):} \\
&amp;\qquad\text{# 1. Apply } \nu_1 \text{ smoothing steps of an iterative method }S_1. \\
&amp;\qquad x_h^{k,1} = S_1^{\nu_1}x_h^{k} \qquad{\scriptsize\textit{# PRE - SMOOTHING}} \\
\\
&amp;\qquad\text{# 2. Restrict defect to coarse grid.}\\
&amp;\qquad d_{2h}^{k} = I_h^{2h}(b_{h} - A_h x_{h}^{k,1}) \qquad{\scriptsize\textit{# }I_h^{2h}\textit{ := restriction operator}} \\
\\
&amp;\qquad\text{# 3. Coarse grid correction.}\\
&amp;\qquad x_{h}^{k,2} = x_{h}^{k,1} + I_{2h}^{h}(A_{2h}^{-1}d_{2h}^{k}) \qquad{\scriptsize\textit{# }I_{2h}^h\textit{ := prolongation operator}} \\
\\
&amp;\qquad\text{# 4. Apply } \nu_2 \text{ smoothing steps of an iterative method }S_2. \\
&amp;\qquad x_{h}^{k,3} = S_2^{\nu_2}x_h^{k,2} \qquad{\scriptsize\textit{# POST - SMOOTHING}} \\
\\
&amp;\qquad\text{return }x_h^{k+1} := x_h^{k,3}\end{split}\]</div>
</div>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>In most cases we want the two-grid method to be a symmetric iteration.
Therefore we need <span class="math notranslate nohighlight">\(\nu := \nu_1 = \nu_2\)</span> and <span class="math notranslate nohighlight">\(S := S_1 = S_2^\ast\)</span> [4],
e.g. choose <span class="math notranslate nohighlight">\(S_1\)</span> as forward Gauss-Seidel and <span class="math notranslate nohighlight">\(S_2\)</span> as backward Gauss-Seidel.
Alternatively we have also implemented the <span class="math notranslate nohighlight">\(\omega\)</span>-Jacobi method which can be used for pre- and post-smoothing.
Furthermore <span class="math notranslate nohighlight">\(A_{2h}^{-1}d_{2h}\)</span> is not feasible to compute with a direct solver
if <span class="math notranslate nohighlight">\(A_{2h}\)</span> is too large, which is often the case.
Thus <span class="math notranslate nohighlight">\(A_{2h}^{-1}d_{2h}\)</span> can be understood as solving the linear equation system and can be done for example by another two-grid method. This recursion then produces the multigrid algorithm.</p>
</div>
</div>
<div class="section" id="multigrid-algorithm">
<h2>Multigrid algorithm<a class="headerlink" href="#multigrid-algorithm" title="Permalink to this headline">¶</a></h2>
<p>TODO</p>
</div>
<div class="section" id="grid-transfer">
<h2>Grid transfer<a class="headerlink" href="#grid-transfer" title="Permalink to this headline">¶</a></h2>
<p>TODO</p>
<p>TODO: Code Examples !!!!!</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">activations</span> <span class="kn">import</span> <span class="n">Softmax</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Softmax</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<ol class="arabic simple">
<li><p>Sven Beuchler. <em>Lecture notes in ‘Multigrid and domain decomposition.’</em> April 2020.</p></li>
<li><p>Thomas Wick. <em>Numerical Methods for Partial Differential Equations.</em> 2020. URL: <a class="reference external" href="https://doi.org/10.15488/9248">https://doi.org/10.15488/9248</a>.</p></li>
<li><p>Dietrich Braess. <em>Finite Elemente.</em> Springer Berlin Heidelberg, 2013. DOI: 10.1007/978-3-642-34797-9. URL: <a class="reference external" href="https://doi.org/10.1007%2F978-3-642-34797-9">https://doi.org/10.1007%2F978-3-642-34797-9</a>.</p></li>
<li><p>Chao Chen. “Geometric multigrid for eddy current problems”. PhD thesis. 2012.</p></li>
</ol>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="results.html" class="btn btn-neutral float-right" title="Results on Benchmark Problem" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral float-left" title="Welcome to Multigrid’s documentation!" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Julian Roth, Max Schröder

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>