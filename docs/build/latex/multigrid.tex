%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english, openany]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

\usepackage{sphinxcontribtikz}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Table of Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}


% Jupyter Notebook code cell colors
\definecolor{nbsphinxin}{HTML}{307FC1}
\definecolor{nbsphinxout}{HTML}{BF5B3D}
\definecolor{nbsphinx-code-bg}{HTML}{F5F5F5}
\definecolor{nbsphinx-code-border}{HTML}{E0E0E0}
\definecolor{nbsphinx-stderr}{HTML}{FFDDDD}
% ANSI colors for output streams and traceback highlighting
\definecolor{ansi-black}{HTML}{3E424D}
\definecolor{ansi-black-intense}{HTML}{282C36}
\definecolor{ansi-red}{HTML}{E75C58}
\definecolor{ansi-red-intense}{HTML}{B22B31}
\definecolor{ansi-green}{HTML}{00A250}
\definecolor{ansi-green-intense}{HTML}{007427}
\definecolor{ansi-yellow}{HTML}{DDB62B}
\definecolor{ansi-yellow-intense}{HTML}{B27D12}
\definecolor{ansi-blue}{HTML}{208FFB}
\definecolor{ansi-blue-intense}{HTML}{0065CA}
\definecolor{ansi-magenta}{HTML}{D160C4}
\definecolor{ansi-magenta-intense}{HTML}{A03196}
\definecolor{ansi-cyan}{HTML}{60C6C8}
\definecolor{ansi-cyan-intense}{HTML}{258F8F}
\definecolor{ansi-white}{HTML}{C5C1B4}
\definecolor{ansi-white-intense}{HTML}{A1A6B2}
\definecolor{ansi-default-inverse-fg}{HTML}{FFFFFF}
\definecolor{ansi-default-inverse-bg}{HTML}{000000}

% Define an environment for non-plain-text code cell outputs (e.g. images)
\makeatletter
\newenvironment{nbsphinxfancyoutput}{%
    % Avoid fatal error with framed.sty if graphics too long to fit on one page
    \let\sphinxincludegraphics\nbsphinxincludegraphics
    \nbsphinx@image@maxheight\textheight
    \advance\nbsphinx@image@maxheight -2\fboxsep   % default \fboxsep 3pt
    \advance\nbsphinx@image@maxheight -2\fboxrule  % default \fboxrule 0.4pt
    \advance\nbsphinx@image@maxheight -\baselineskip
\def\nbsphinxfcolorbox{\spx@fcolorbox{nbsphinx-code-border}{white}}%
\def\FrameCommand{\nbsphinxfcolorbox\nbsphinxfancyaddprompt\@empty}%
\def\FirstFrameCommand{\nbsphinxfcolorbox\nbsphinxfancyaddprompt\sphinxVerbatim@Continues}%
\def\MidFrameCommand{\nbsphinxfcolorbox\sphinxVerbatim@Continued\sphinxVerbatim@Continues}%
\def\LastFrameCommand{\nbsphinxfcolorbox\sphinxVerbatim@Continued\@empty}%
\MakeFramed{\advance\hsize-\width\@totalleftmargin\z@\linewidth\hsize\@setminipage}%
\lineskip=1ex\lineskiplimit=1ex\raggedright%
}{\par\unskip\@minipagefalse\endMakeFramed}
\makeatother
\newbox\nbsphinxpromptbox
\def\nbsphinxfancyaddprompt{\ifvoid\nbsphinxpromptbox\else
    \kern\fboxrule\kern\fboxsep
    \copy\nbsphinxpromptbox
    \kern-\ht\nbsphinxpromptbox\kern-\dp\nbsphinxpromptbox
    \kern-\fboxsep\kern-\fboxrule\nointerlineskip
    \fi}
\newlength\nbsphinxcodecellspacing
\setlength{\nbsphinxcodecellspacing}{0pt}

% Define support macros for attaching opening and closing lines to notebooks
\newsavebox\nbsphinxbox
\makeatletter
\newcommand{\nbsphinxstartnotebook}[1]{%
    \par
    % measure needed space
    \setbox\nbsphinxbox\vtop{{#1\par}}
    % reserve some space at bottom of page, else start new page
    \needspace{\dimexpr2.5\baselineskip+\ht\nbsphinxbox+\dp\nbsphinxbox}
    % mimick vertical spacing from \section command
      \addpenalty\@secpenalty
      \@tempskipa 3.5ex \@plus 1ex \@minus .2ex\relax
      \addvspace\@tempskipa
      {\Large\@tempskipa\baselineskip
             \advance\@tempskipa-\prevdepth
             \advance\@tempskipa-\ht\nbsphinxbox
             \ifdim\@tempskipa>\z@
               \vskip \@tempskipa
             \fi}
    \unvbox\nbsphinxbox
    % if notebook starts with a \section, prevent it from adding extra space
    \@nobreaktrue\everypar{\@nobreakfalse\everypar{}}%
    % compensate the parskip which will get inserted by next paragraph
    \nobreak\vskip-\parskip
    % do not break here
    \nobreak
}% end of \nbsphinxstartnotebook

\newcommand{\nbsphinxstopnotebook}[1]{%
    \par
    % measure needed space
    \setbox\nbsphinxbox\vbox{{#1\par}}
    \nobreak % it updates page totals
    \dimen@\pagegoal
    \advance\dimen@-\pagetotal \advance\dimen@-\pagedepth
    \advance\dimen@-\ht\nbsphinxbox \advance\dimen@-\dp\nbsphinxbox
    \ifdim\dimen@<\z@
      % little space left
      \unvbox\nbsphinxbox
      \kern-.8\baselineskip
      \nobreak\vskip\z@\@plus1fil
      \penalty100
      \vskip\z@\@plus-1fil
      \kern.8\baselineskip
    \else
      \unvbox\nbsphinxbox
    \fi
}% end of \nbsphinxstopnotebook

% Ensure height of an included graphics fits in nbsphinxfancyoutput frame
\newdimen\nbsphinx@image@maxheight % set in nbsphinxfancyoutput environment
\newcommand*{\nbsphinxincludegraphics}[2][]{%
    \gdef\spx@includegraphics@options{#1}%
    \setbox\spx@image@box\hbox{\includegraphics[#1,draft]{#2}}%
    \in@false
    \ifdim \wd\spx@image@box>\linewidth
      \g@addto@macro\spx@includegraphics@options{,width=\linewidth}%
      \in@true
    \fi
    % no rotation, no need to worry about depth
    \ifdim \ht\spx@image@box>\nbsphinx@image@maxheight
      \g@addto@macro\spx@includegraphics@options{,height=\nbsphinx@image@maxheight}%
      \in@true
    \fi
    \ifin@
      \g@addto@macro\spx@includegraphics@options{,keepaspectratio}%
    \fi
    \setbox\spx@image@box\box\voidb@x % clear memory
    \expandafter\includegraphics\expandafter[\spx@includegraphics@options]{#2}%
}% end of "\MakeFrame"-safe variant of \sphinxincludegraphics
\makeatother

\makeatletter
\renewcommand*\sphinx@verbatim@nolig@list{\do\'\do\`}
\begingroup
\catcode`'=\active
\let\nbsphinx@noligs\@noligs
\g@addto@macro\nbsphinx@noligs{\let'\PYGZsq}
\endgroup
\makeatother
\renewcommand*\sphinxbreaksbeforeactivelist{\do\<\do\"\do\'}
\renewcommand*\sphinxbreaksafteractivelist{\do\.\do\,\do\:\do\;\do\?\do\!\do\/\do\>\do\-}
\makeatletter
\fvset{codes*=\sphinxbreaksattexescapedchars\do\^\^\let\@noligs\nbsphinx@noligs}
\makeatother

\usepackage{tikz}

\usepackage{listings}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.96}
\definecolor{lightgray}{rgb}{1,1,1}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{lightgray},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    xleftmargin=3pt
}
 
\lstset{style=mystyle}

\title{Multigrid}
\date{June 19, 2020}
\release{}%1.0.0
\author{Julian Roth, Max Schröder}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}%Release
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}


\chapter{Basics of Geometric Multigrid}
\label{\detokenize{basics:basics-of-geometric-multigrid}}\label{\detokenize{basics::doc}}



\section{Introduction}
\label{\detokenize{basics:introduction}}
In the following, we are describing the {\color{blue}{geometric multigrid method}},
which for certain problems yields an iterative solver
with optimal cost complexity, i.e. the solver returns a solution to a PDE in
\(O(n_{\text{DoFs}})\) arithmetic operations. We will show that this can also
be achieved for some convection\sphinxhyphen{}diffusion equations on uniformly refined triangular
meshes, when discretizing with linear finite elements.


\section{Problem setup}
\label{\detokenize{basics:problem-setup}}
Let \(\Omega := (-1,1)^2 \setminus (0,1)^2\) be an L\sphinxhyphen{}shaped {\color{blue}{domain}}. We decompose the boundary of this domain \(\partial\Omega\) into the Neumann boundary \(\Gamma_D := (0,1) \times \{0\} \cup \{0\} \times (0,1)\)
and the Dirichlet boundary \(\Gamma_N := \partial\Omega \setminus \Gamma_D\).

Next, we define the {\color{blue}ansatz} and {\color{blue}test function space} \(V := \left\{ u \in H^1(\Omega)\mid u = 0 \text{ on } \Gamma_D \right\}\),
where
\begin{equation*}
\begin{split}H^1(\Omega) := W^{1,2}(\Omega) := \left\{ u \in L^2(\Omega) \mid |\nabla u| \in L^2( \Omega ) \right\}\end{split}
\end{equation*}
is the Sobolev space containing the weakly differentiable functions
in \(\Omega\). Note that we haven’t explicitly prescribed any boundary conditions on \(\Gamma_N\) in the function space,
since the homogeneous Neumann boundary conditions come up naturally when deriving the variational form of the problem.
Further, we need a right hand side function
\begin{equation*}
\begin{split}f(x) :=
\begin{cases}
   -1 & \text{for } x \in (-1,0) \times (0,1) \\
   0 & \text{for } x \in (-1,0) \times (-1,0) \\
   1 & \text{for } x \in (0,1) \times (-1,0) \\
\end{cases}.\end{split}
\end{equation*}
\begin{figure}[H]
\centering
\def\svgwidth{0.6\columnwidth}
    \input{domain.pdf_tex}
\end{figure}

\begin{center}Figure 1: Domain \(\Omega\)
\end{center}
Using the parameters \(a = 1\) and \(c = 0\) in \(\Omega\), we can now
formulate the strong form of our convection diffusion equation:

\begin{sphinxadmonition}{note}{Strong form}

Find \(u: \Omega \rightarrow \mathbb{R}\) such that
\begin{equation*}
\begin{split}-\nabla \cdot \left( a \nabla u\right) + c u &= f \quad \text{in } \Omega \qquad (1)\\
u &= 0 \quad \text{on } \Gamma_D \\
\partial_n u &= 0 \quad \text{on } \Gamma_N\end{split}
\end{equation*}\end{sphinxadmonition}

In the above formulation, we used the notation \(\partial n := \nabla \cdot n\).
To be able to solve this problem, we need to convert it into its integral form.
Therefore we multiply (1) from the right with a test function \(v \in V\) and integrate over \(\Omega\).
\begin{equation*}
\begin{split}-\int_{\Omega} \left(\nabla \cdot \left( a \nabla u\right)\right) \cdot v\ dx
+ \int_{\Omega} c u \cdot v\ dx
= \int_{\Omega} f \cdot v\ dx \quad \forall v \in V\end{split}
\end{equation*}
Now integration of parts can be applied to the first integral and we use the fact that \(\partial \Omega = \Gamma_D\ \dot\cup\ \Gamma_N\).
\begin{equation*}
\begin{split}\int_{\Omega} a \nabla u \cdot \nabla v\ dx
-\int_{\Gamma_D} a \partial_n u \cdot v\ ds
-\int_{\Gamma_N} a \partial_n u \cdot v\ ds \\
+ \int_{\Omega} c u \cdot v\ dx
= \int_{\Omega} f \cdot v\ dx \quad \forall v \in V\end{split}
\end{equation*}
Note that the integrals over the boundaries \(\Gamma_D\) and \(\Gamma_N\) vanish,
since \(\partial_n u = 0\) on \(\Gamma_N\) and, due to \(v \in V\), \(u = 0\) on \(\Gamma_D\).
Thus we have derived the following integral problem of our problem,
which is often referred to as the weak or variational form in the literature.

\begin{sphinxadmonition}{note}{Weak form}

Find \(u \in V\) such that
\begin{equation*}
\begin{split}a(u,v) = l(v) \quad \forall v \in V\end{split}
\end{equation*}
where \(a: V \times V \rightarrow \mathbb{R}\) is the bilinear form defined as
\begin{equation*}
\begin{split}a(u,v) := \int_{\Omega} a \nabla u \cdot \nabla v\ dx + \int_{\Omega} c u \cdot v\ dx\end{split}
\end{equation*}
and the right hand side \(l: V \rightarrow \mathbb{R}\) is a linear form defined as
\begin{equation*}
\begin{split}l(v) := \int_{\Omega} f \cdot v\ dx\end{split}
\end{equation*}\end{sphinxadmonition}

Furthermore using the fundamental lemma of calculus of variations, it can be shown that the strong and the weak form
are equivalent. Hence it suffices to solve the weak form of the problem.


\section{Finite Element Method}
\label{\detokenize{basics:finite-element-method}}
The problem that we are facing is that \(V\) is an infinite dimensional function space
and we need the ability to solve the weak form with a classical computer.
Hence instead we work with a finite dimensional subspace \(V_h \subset V\).
This will enable us to rewrite the weak form as a linear equation system.

Let a subdivision of \(\Omega\) into {\color{blue}finite elements} \((K,P_1,\Sigma)\)
be given, where
\begin{itemize}
\item {} 
\(K\) is a two dimensional right triangle,

\item {} 
\(P_1(K) := \operatorname{span}\{1-x_1-x_2, x_1, x_2 \}\) is the space of linear functions defined on \(K\),

\item {} 
\(\Sigma := \{a_0, a_1, a_2 \}\) is a set of {\color{blue}degrees of freedom} (DoF), which here are the values of the polynomial at the vertices of \(K\).

\end{itemize}

Then a \(P_1(K)\) function is defined by
\begin{equation*}
\begin{split}u(x) = a_0 + a_1x_1 + a_2x_2 \quad \forall x = (x_1,x_2) \in K.\end{split}
\end{equation*}
To recapitulate: First, we have divided \(\Omega\) into triangles \(K_1, ..., K_m\). Examples for this can be found in the section {\hyperref[\detokenize{basics:grid-setup}]{\emph{“Grid Setup”}}}.
Secondly, we have seen that we have the parameters (DoFs) which can describe any linear function on such a triangle \(K_k\).
Now simply define our function space \(V_h\) as the space of functions which are continuous on the whole domain \(\Omega\), linear on each triangle \(K_k\) and satisfy the Dirichlet boundary conditions, i.e.
\begin{equation*}
\begin{split}V_h := \{ v_h \in C(\Omega) \mid v_h |_{K_k} \in P_1(K_k) \quad \forall 1 \leq k \leq m,\ v_h = 0 \text{ on } \Gamma_D \}.\end{split}
\end{equation*}
We use the index \(h\) to show that we are not longer using the infinite dimensional function space \(V\),
but a finite dimensional subspace which is defined on triangles \(K_k\) where the short sides have length \(h\).
By working with \(V_h\), we now try to find an element\sphinxhyphen{}wise linear approximation to the solution of the weak form.

Thus we are now trying to solve the discrete weak form:

\begin{sphinxadmonition}{note}{Discrete weak form}

Find \(u_h \in V_h\) such that
\begin{equation*}
\begin{split}a(u_h,v_h) = l(v_h) \quad \forall v_h \in V_h\end{split}
\end{equation*}\end{sphinxadmonition}

Furthermore, we know that \(V_h\) is finite dimensional and we can write down its basis, since we know the bases of \(P_1(K_k)\).
Hence
\begin{equation*}
\begin{split}V_h = \operatorname{span}\{ \phi_1, \dots, \phi_{n_{DoFs}} \},\end{split}
\end{equation*}
where \(\phi_i\) is the basis function corresponding to the i.th degree of freedom, i.e. the i.th grid point. It follows that
\begin{equation*}
\begin{split}u_h = \sum_{i= 0}^{n_{DoFs}} u_i \phi_i \quad \text{and} \quad v_h = \sum_{i= 0}^{n_{DoFs}} v_i \phi_i\end{split}
\end{equation*}
for some \(\begin{pmatrix}u_1, \dots u_{n_{DoFs}}\end{pmatrix}^T, \begin{pmatrix}v_1, \dots v_{n_{DoFs}}\end{pmatrix}^T \in \mathbb{R}^{n_{DoFs}}\). Therefore the discrete weak form can be written as
\begin{equation*}
\begin{split}a\left(\sum_{i= 0}^{n_{DoFs}} u_i \phi_i,\sum_{j= 0}^{n_{DoFs}} v_j \phi_j \right) = l\left(\sum_{j= 0}^{n_{DoFs}} v_j \phi_j \right).\end{split}
\end{equation*}
Since \(a\) is linear in the second argument and \(l\) is also linear, it is thus sufficient to solve
\begin{equation*}
\begin{split}a\left(\sum_{i= 0}^{n_{DoFs}} u_i \phi_i,\phi_j \right) = l\left(\phi_j \right) \quad \forall 1 \leq j \leq n_{DoFs}.\end{split}
\end{equation*}
The convection\sphinxhyphen{}diffusion problem is linear itself, thus \(a\) is also linear in the first argument and we get
\begin{equation*}
\begin{split}\sum_{i= 0}^{n_{DoFs}} u_i\ a\left(\phi_i,\phi_j \right) = l\left(\phi_j \right) \quad \forall 1 \leq j \leq n_{DoFs}.\end{split}
\end{equation*}
This can also be written as a linear equation system
\begin{equation*}
\begin{split}\begin{bmatrix}
  a\left(\phi_1,\phi_1 \right) & \cdots & a\left(\phi_{n_{DoFs}},\phi_1 \right) \\
  \vdots & \ddots & \vdots \\
  a\left(\phi_1,\phi_{n_{DoFs}} \right) & \cdots & a\left(\phi_{n_{DoFs}},\phi_{n_{DoFs}} \right)
\end{bmatrix}
\begin{bmatrix}
  u_1\\
  \vdots\\
  u_{n_{DoFs}}
\end{bmatrix}
=
\begin{bmatrix}
  l(u_1)\\
  \vdots\\
  l(u_{n_{DoFs}})
\end{bmatrix}.\end{split}
\end{equation*}
To remain consistent with future chapters, we follow the naming convention
\begin{equation*}
\begin{split}A_h &:= \begin{bmatrix}
  a\left(\phi_1,\phi_1 \right) & \cdots & a\left(\phi_{n_{DoFs}},\phi_1 \right) \\
  \vdots & \ddots & \vdots \\
  a\left(\phi_1,\phi_{n_{DoFs}} \right) & \cdots & a\left(\phi_{n_{DoFs}},\phi_{n_{DoFs}} \right)
\end{bmatrix}, \\
x_h &:= \begin{bmatrix}
  u_1\\
  \vdots\\
  u_{n_{DoFs}}
\end{bmatrix}  \quad \text{ and } \\
b_h &:= \begin{bmatrix}
  l(u_1)\\
  \vdots\\
  l(u_{n_{DoFs}})
\end{bmatrix}.\end{split}
\end{equation*}
To be able to solve \(A_h x_h = b_h\), we need an efficient way to compute \(a\left(\phi_i,\phi_j \right)\) and \(l\left(\phi_j \right)\).
For that we use that \(\Omega = \cup_{k = 1}^{n_{DoFs}}K_k\) and we thus get
\begin{equation*}
\begin{split}a(\phi_i,\phi_j) &= \int_{\Omega} a \nabla \phi_i \cdot \nabla \phi_j\ dx + \int_{\Omega} c \phi_i \cdot \phi_j\ dx \\
                &= \sum_{k = 1}^{n_{DoFs}} \left( \int_{K_k} a \nabla \phi_i \cdot \nabla \phi_j\ dx + \int_{K_k} c \phi_i \cdot \phi_j\ dx  \right),\end{split}
\end{equation*}
similarly we get for the right hand functional
\begin{equation*}
\begin{split}l(\phi_j) &= \int_{\Omega} f \cdot \phi_j\ dx \\
          &= \sum_{k = 1}^{n_{DoFs}} \left( \int_{K_k} f \cdot \phi_j\ dx \right).\end{split}
\end{equation*}
Note that many of these integrals are zero, since the basis functions \(\phi_i\) only have support on the triangles that contain the vertex corresponding
to the i.th degree of freedom. Furthermore, we use the isoparametric concept that allows us to assemble the {\color{blue}system matrix} \(A_h\) and {\color{blue}right side} \(b_h\)
by once computing integrals on a reference element \(\hat{K}\) and then transforming the results to the elements \(K_k\).

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=294\sphinxpxdimen,height=159\sphinxpxdimen]{{trafo}.png}
\end{figure}

\begin{center}Figure 2: Transformation from reference element to finite element
\end{center}
We now apply the transformation theorem
\begin{equation*}
\begin{split}\int_{\hat{K}} g\left(T_k\left(\hat{x}\right)\right)\left|\det\left(\nabla T_k\left(\hat{x}\right)\right)\right|\ d\hat{x} = \int_{K_k} g\left(x\right)\ dx\end{split}
\end{equation*}
to all integrals that need to be evaluated in the discrete weak form.

Then the algorithm for the assembly is given by

\lstset{language=Python}
\lstset{escapeinside={<@}{@>}}
\begin{lstlisting}[mathescape=true]
for <@\textcolor{black!40!green}{triangle}@> $K$ in grid.triangles:
	for <@\textcolor{black!40!green}{DoF}@> $\phi_i$ in $K$.dofs:
		$b_h$[$\phi_i$.globalIndex] += $f \int_{\hat{K}} \hat{\phi}_i \left|\det\left(\hat{\nabla} T_K(\hat{x})\right)\right|\ d\hat{x}$
		for <@\textcolor{black!40!green}{DoF}@> $\phi_j$ in $K$.dofs:
			$A_h$[$\phi_i$.globalIndex, $\phi_j$.globalIndex] += (
				$a \int_{\hat{K}} \left(\hat{\nabla} T_K\left(\hat{x}\right)^{-T}\hat{\nabla}\hat{\phi}_i \right) \cdot \left(\hat{\nabla} T_K\left(\hat{x}\right)^{-T}\hat{\nabla}\hat{\phi}_j \right) \left|\det\left(\hat{\nabla} T_K(\hat{x})\right)\right|\ d\hat{x}$ +
				$c \int_{\hat{K}} \hat{\phi}_i \cdot  \hat{\phi}_j \left|\det\left(\hat{\nabla} T_K(\hat{x})\right)\right|\ d\hat{x}$
			)
\end{lstlisting}

where \(\hat{\phi}_i = \phi_i \circ T_k\) are the basis functions on the reference element.

At the end of the assembly, we need to account for the Dirichlet boundary constraints, e.g. let a constraint \(u_{\tau} = \xi\) be given.
Then we would need to make sure that \((A_h)_{\tau,j} = \delta_{\tau,j}\) for all \(1 \leq j \leq m\).
Here \(\delta_{\tau,j}\) denotes the Kronecker delta, which is defined as
\begin{equation*}
\begin{split}\delta_{\tau,j} := \begin{cases}
  1 & \text{for } j = \tau \\
  0 & \text{for } j \neq \tau
  \end{cases}.\end{split}
\end{equation*}
Futhermore, we would need to set \((b_h)_{\tau} = \xi\).
Obviously these steps ensure that when solving the linear system \(A_h x_h = b_h\),
we get \(u_{\tau} = \xi\). In our model problem, we only have homogeneous Dirichlet constraints.
Thus, we only need to find all indices \(\tau\) at the Dirichlet boundary \(\Gamma_D\)
and apply the procedure from above with \(\xi = 0\).

Overall, the Finite Element Method enabled us to transform a discrete form of the convection\sphinxhyphen{}diffusion equation
on a given grid into a linear equation system. In the following, we will investigate how such a linear equation system can be solved iteratively.


\section{Iterative Methods}
\label{\detokenize{basics:iterative-methods}}
We want to construct an iteration, where each iterate \(x_k^{k}\) is a better approximation to the linear equation system \(A_h x_h = b_h\).
To measure the quality of our solution, we monitor the {\color{blue}defect}
\begin{equation*}
\begin{split}b_h - A_h x_h\end{split}
\end{equation*}
and try to minimize it.
One can try to formulate a fixed point scheme \(x_h^{k+1} = g\left(x_h^{k}\right)\) to solve the system of equations.
The goal of the fixed point scheme is to find some input \(x\) such that \(g(x) = x\).
In our case, we want the exact solution \(x_h\) to be a fixed point of our iteration.
We observe that the defect of the exact solution is zero. Thus one might try to increment the old iterate \(x_h\)
by some multiple of the defect. This is called the Richardson method. However, the Richardson method is rarely used in practice.
Instead we will work with the more general fixed point scheme
\begin{equation*}
\begin{split}x_h^{k+1} = x_h^{k} + \omega C^{-1}\left(b_h - A_h x_h^{k} \right)\end{split}
\end{equation*}
where \(C \in \mathbb{R}^{n_{DoFs} \times n_{DoFs}}\). Here the type of method depends on the matrix \(C\), e.g.
\(C = I\) is the Richardson method. In our code, we implemented
\begin{itemize}
\item {} 
\(C = D\) which is the \(\omega\)\sphinxhyphen{}{\color{blue}Jacobi} method,

\item {} 
\(C = \left( D + L \right)\) which is the  {\color{blue}Forward Gauss\sphinxhyphen{}Seidel} method for \(\omega = 1\),

\item {} 
\(C = \left( D + U \right)\) which is the  {\color{blue}Backward Gauss\sphinxhyphen{}Seidel} method for \(\omega = 1\).

\end{itemize}

In these definitions, we used the decomposition  \(A_h = L + D + U\), where \(L\) has only nonzero entries below the diagonal (strictly lower triangular matrix),
\(D\) has only nonzero entries on the diagonal (diagonal matrix) and \(U\) has only nonzero entries above the diagonal (strictly upper triangular matrix).

Note that we need to compute the inverse matrix \(C^{-1}\). This can be easily done for \(\omega\)\sphinxhyphen{}Jacobi,
since we just invert the diagonal. It wouldn’t be efficient to invert \(\left( D + L \right)\) or \(\left( D + U \right)\) directly.
Hence we use the formula
\begin{equation*}
\begin{split}x_i^k = \frac{1}{a_{ii}}\left( b_i - \sum_{j < i}a_{ij}x_j^k - \sum_{j > i}a_{ij}x_j^{k-1} \right) \quad \text{for } i = 1, \dots n_{DoFs}\end{split}
\end{equation*}
for Forward Gauss\sphinxhyphen{}Seidel and the formula
\begin{equation*}
\begin{split}x_i^k = \frac{1}{a_{ii}}\left( b_i - \sum_{j < i}a_{ij}x_j^{k-1} - \sum_{j > i}a_{ij}x_j^{k} \right) \quad \text{for } i = n_{DoFs},  \dots, 1\end{split}
\end{equation*}
for Backward Gauss\sphinxhyphen{}Seidel. In these formulas, we used the notation \(a_{ij} := (A_h)_{ij}\), \(b_{i} := (b_h)_{i}\) and \(x_i^{k} := (x_h^{k})_i\).

Which of these iterative methods should be used in numerical computations? It depends!
\(\omega\)\sphinxhyphen{}Jacobi has the benefit of being fast, since it can be parallelized.
Nevertheless, it needs more iterations to converge than Gauss\sphinxhyphen{}Seidel and one needs to choose a good value for \(\omega\) before computation.
Although the Gauss\sphinxhyphen{}Seidel methods converge in less iterations, they need longer for the computation, since the for loops need to be executed sequentially.

In the next few sections, we will show how \(\omega\)\sphinxhyphen{}Jacobi and Gauss\sphinxhyphen{}Seidel can be used in the multigrid method,
resulting in a fast solver for the linear equation system derived from a discrete weak form of the convection\sphinxhyphen{}diffusion equation.


\section{Grid Setup}
\label{\detokenize{basics:grid-setup}}
To transform the weak form of our problem into a linear equation system,
we first need to discretize our domain. For that purpose, we create an initial triangulation of the domain,
i.e. we divide \(\Omega\) into a set of triangles. We call this triangulation the {\color{blue}coarse grid} and denote it as \(\mathbb{T}_0\).
The grid consists of objects of type \sphinxcode{\sphinxupquote{Node}}, \sphinxcode{\sphinxupquote{Edge}} and \sphinxcode{\sphinxupquote{Triangle}}.

\begin{figure}[H]
\centering
\def\svgwidth{0.6\columnwidth}
    \input{CoarseGrid.pdf_tex}
\end{figure}

\begin{center}Figure 3: Coarse grid (\(\mathbb{T}_0\))
\end{center}
For the multigrid method, we need a sequence of such grids.
In this work, we restrict our analysis to uniformly refined meshes.
How can we create these refined meshes? We have to loop over all triangles of the grid
and then refine them.

\begin{figure}[H]
\centering
\def\svgwidth{0.4\columnwidth}
    \input{triangle_refinement.pdf_tex}
\end{figure}

\begin{center}Figure 4: Refining a triangle
\end{center}
To refine a triangle one simply needs to bisect all of its edges and draw a new triangle out of these three new nodes.
As shown in figure 4, through the refinement process a triangle is being divided
into four smaller triangles. Each \sphinxcode{\sphinxupquote{Node}} object needs to know its parent nodes.
The parents are two end nodes of the edge that has been bisected, e.g. node 1 and node 2 are the parents of node 4.
In the literature {[}1{]} these relationships are being stored in a father\sphinxhyphen{}son list.
This is not needed in our case, due to Object Oriented Programming (OOP).

Having refined all triangles of the coarse grid, we get a new triangulation \(\mathbb{T}_1\),
which is called the grid on level 1. The {\color{blue}level} of a grid indicates how often we need to (globally)
refine the coarse grid to construct that grid.

\begin{figure}[H]
\centering
\def\svgwidth{0.6\columnwidth}
    \input{GridLevel1.pdf_tex}
\end{figure}

\begin{center}Figure 5: Grid on level 1 (\(\mathbb{T}_1\))
\end{center}
We continue the process of refining the grid, until we end up with a grid, which has enough nodes
to ensure that a sufficiently good approximation to the exact solution can be computed.

\begin{figure}[H]
\centering
\def\svgwidth{0.6\columnwidth}
    \input{GridLevel2.pdf_tex}
\end{figure}

\begin{center}Figure 6: Grid on level 2 (\(\mathbb{T}_2\))
\end{center}
The grid on the highest level, in this case \(\mathbb{T}_2\) or more generally \(\mathbb{T}_L\), is called the finest grid
and will be used to assemble the system matrix.

Using the Finite Element Method, we can discretize the weak form of our PDE on each level grid
with linear finite elements. For each level \(0 \leq l \leq L\), we get a linear equation system
\begin{equation*}
\begin{split}A_l x_l = b_l \text{  with  } A_l \in \mathbb{R}^{n_l \times n_l}, x_l, b_l \in \mathbb{R}^{n_l},\end{split}
\end{equation*}
where \(n_l\) is the number of degrees of freedom (DoFs), which in our case corresponds to the number of nodes in the grid.
Note that the discrete function spaces \(\left( V_l \right)_{l=0}^L\) from the FEM are conforming finite element spaces,
i.e. \(V_0 \subset V_1 \subset \cdots \subset V_L\). If this wasn’t the case, the grid transfer operations, which will be introduced shortly, would need to be modified.


\section{Two\sphinxhyphen{}grid algorithm}
\label{\detokenize{basics:two-grid-algorithm}}
To understand the multigrid algorithm we start by looking at the case where we only have two grids \(\mathbb{T}_{l}\) and \(\mathbb{T}_{l+1}\).
The mulitgrid algorithm is then only a recursive application of the two grid version.

\begin{sphinxadmonition}{note}{Two\sphinxhyphen{}grid algorithm}

Let \(A_h x_h = b_h\) and \(A_{2h} x_{2h} = b_{2h}\) with \(A_h \in \mathbb{R}^{n \times n}\),
\(A_{2h} \in \mathbb{R}^{m \times m}\) and \(m < n\)
denote the linear equation systems from the grids \(\mathbb{T}_{l+1}\) and \(\mathbb{T}_{l}\).
Let the k\sphinxhyphen{}th iterate \(x_h^k\) on the finer grid be given.

\begin{center}
\lstset{language=Python}
\begin{lstlisting}[mathescape=true]
def TGM($\boldsymbol{x_h^k}$):
	# 1. Apply $\nu_1$ smoothing steps of an iterative method $\boldsymbol{S_1}$.
	$\boldsymbol{x_h^{k,1}} = \boldsymbol{S_1}^{\nu_1}\boldsymbol{x_h^{k}}$			# PRE - SMOOTHING
	
	# 2. Restrict defect to coarse grid.
	$\boldsymbol{d_{2h}} = I_h^{2h}(\boldsymbol{b_{h}} - A_h\boldsymbol{x_{h}^{k,1}})$			# $I_h^{2h}$ := restriction operator
	
	# 3. Coarse grid correction.
	$\boldsymbol{x_{h}^{k,2}} = \boldsymbol{x_{h}^{k,1}} + I_{2h}^{h}(A_{2h}^{-1}\boldsymbol{d_{2h}})$		# $I_{2h}^{h}$ := prolongation operator
	
	# 4. Apply $\nu_2$ smoothing steps of an iterative method $\boldsymbol{S_2}$.
	$\boldsymbol{x_h^{k,3}} = \boldsymbol{S_2}^{\nu_2}\boldsymbol{x_h^{k,2}}$			# POST - SMOOTHING
	
	return $\boldsymbol{x_h^{k+1}} := \boldsymbol{x_h^{k,3}}$
\end{lstlisting}
\end{center}

\end{sphinxadmonition}

\begin{sphinxadmonition}{hint}{Hint:}
In most cases we want the two\sphinxhyphen{}grid method to be a symmetric iteration.
Therefore we need \(\nu := \nu_1 = \nu_2\) and \(S := S_1 = S_2^\ast\) {[}4{]},
e.g. choose \(S_1\) as forward Gauss\sphinxhyphen{}Seidel and \(S_2\) as backward Gauss\sphinxhyphen{}Seidel.
Alternatively we have also implemented the \(\omega\)\sphinxhyphen{}Jacobi method which can be used for pre\sphinxhyphen{} and post\sphinxhyphen{}smoothing.
Furthermore \(A_{2h}^{-1}d_{2h}\) is not feasible to compute with a direct solver
if \(A_{2h}\) is too large, which is often the case.
Thus \(A_{2h}^{-1}d_{2h}\) can be understood as solving the linear equation system and can be done for example by another two\sphinxhyphen{}grid method. This recursion then produces the multigrid algorithm.
\end{sphinxadmonition}


\section{Multigrid algorithm}
\label{\detokenize{basics:multigrid-algorithm}}
\begin{sphinxadmonition}{note}{Multigrid algorithm}

Let \(A_L x_L = b_L\) denote the problem on the finest grid and \(A_l x_l = b_l\)
the problems on the coarser grids for \(0 \leq l \leq L-1\).
Let \(\nu\) denote the number of pre\sphinxhyphen{} and post\sphinxhyphen{}smoothing steps.
Let the k\sphinxhyphen{}th iterate \(x_l^k\) on the l\sphinxhyphen{}th level be given.

\lstset{language=Python}
\begin{lstlisting}[mathescape=true]
def MGM($l,\boldsymbol{x_l^k},\boldsymbol{b_l}$): 
	# 1. Apply $\nu$ smoothing steps of an iterative method $\boldsymbol{S}$.
	$\boldsymbol{x_l^{k,1}} = \boldsymbol{S}^{\nu}\boldsymbol{x_l^{k}}$			# PRE - SMOOTHING
	
	# 2. Restrict defect to coarse grid.
	$\boldsymbol{d_{l-1}} = I_l^{l-1}(\boldsymbol{b_{l}} - A_l\boldsymbol{x_{l}^{k,1}})$			# $I_l^{l-1}$ := restriction operator
	
	# 3. Coarse grid solution.
	if l == 1:
		$\boldsymbol{y_{0}} = A_0^{-1}\boldsymbol{d_{0}}$ 		# direct solver on coarsest grid
	else:	# l > 1
		$\boldsymbol{y_{l-1}} = \boldsymbol{0}$
		for i in range($\mu$):
			$\boldsymbol{y_{l-1}} = $ MGM($l-1,\boldsymbol{y_{l-1}},\boldsymbol{d_{l-1}}$)
	
	# 4. Coarse grid correction.
	$\boldsymbol{x_l^{k,2}} = \boldsymbol{x_l^{k,1}} + I_{l-1}^{l}\boldsymbol{y_{l-1}}$			 # $I_{l-1}^{l}$ := prolongation operator
	
	# 5. Apply $\nu$ smoothing steps of an iterative method $\boldsymbol{S}$.
	$\boldsymbol{x_l^{k,3}} = \boldsymbol{S}^{\nu}\boldsymbol{x_l^{k,2}}$			# POST - SMOOTHING
	
	return $\boldsymbol{x_l^{k+1}} := \boldsymbol{x_l^{k,3}}$
\end{lstlisting}
\end{sphinxadmonition}

The parameter \(\mu \in \mathbb{N}^+\) determines the {\color{blue}cycle} of the multigrid iteration.
For \(\mu = 1\) we get the V\sphinxhyphen{}cycle
\begin{center}\begin{tikzpicture}
\node (A) at (0,3) [circle, minimum size=2mm, inner sep=0pt,draw] {};
\node (B) at (1,2) [circle, minimum size=2mm, inner sep=0pt,draw] {};
\node (C) at (2,1) [circle, minimum size=2mm, inner sep=0pt,draw] {};
\node (D) at (3,0) [circle, minimum size=2mm, inner sep=0pt,fill = black, draw] {};
\node (E) at (4,1) [circle, minimum size=2mm, inner sep=0pt,draw] {};
\node (F) at (5,2) [circle, minimum size=2mm, inner sep=0pt,draw] {};
\node (G) at (6,3) [circle, minimum size=2mm, inner sep=0pt,draw] {};
\node [color=black] at (-1,3) {\tiny $l = 3$};
\node [color=black] at (-1,2) {\tiny $l = 2$};
\node [color=black] at (-1,1) {\tiny $l = 1$};
\node [color=black] at (-1,0) {\tiny $l = 0$};
{\color{blue}
\draw[->] (A) to (B);
\draw[->] (B) to (C);
\draw[->] (C) to (D);
}
{\color{black!40!green}
\draw[->] (D) to (E);
\draw[->] (E) to (F);
\draw[->] (F) to (G);
}
\end{tikzpicture}\end{center}
\begin{center}Figure 7: V\sphinxhyphen{}cycle
\end{center}
and for \(\mu = 2\) we get the W\sphinxhyphen{}cycle.
\begin{center}\begin{tikzpicture}
\node (A) at (0,3) [circle, minimum size=2mm, inner sep=0pt,draw] {};
\node (B) at (1,2) [circle, minimum size=2mm, inner sep=0pt,draw] {};
\node (C) at (2,1) [circle, minimum size=2mm, inner sep=0pt,draw] {};
\node (D) at (3,0) [circle, minimum size=2mm, inner sep=0pt,fill = black, draw] {};
\node (E) at (4,1) [circle, minimum size=2mm, inner sep=0pt,draw] {};
\node (F) at (5,0) [circle, minimum size=2mm, inner sep=0pt,fill = black, draw] {};
\node (G) at (6,1) [circle, minimum size=2mm, inner sep=0pt,draw] {};
\node (H) at (7,2) [circle, minimum size=2mm, inner sep=0pt,draw] {};
\node (I) at (8,1) [circle, minimum size=2mm, inner sep=0pt,draw] {};
\node (J) at (9,0) [circle, minimum size=2mm, inner sep=0pt,fill = black, draw] {};
\node (K) at (10,1) [circle, minimum size=2mm, inner sep=0pt,draw] {};
\node (L) at (11,0) [circle, minimum size=2mm, inner sep=0pt,fill = black, draw] {};
\node (M) at (12,1) [circle, minimum size=2mm, inner sep=0pt,draw] {};
\node (N) at (13,2) [circle, minimum size=2mm, inner sep=0pt,draw] {};
\node (O) at (14,3) [circle, minimum size=2mm, inner sep=0pt,draw] {};
\node [color=black] at (-1,3) {\scriptsize $l = 3$};
\node [color=black] at (-1,2) {\scriptsize $l = 2$};
\node [color=black] at (-1,1) {\scriptsize $l = 1$};
\node [color=black] at (-1,0) {\scriptsize $l = 0$};
{\color{blue}
\draw[->] (A) to (B);
\draw[->] (B) to (C);
\draw[->] (C) to (D);
}
{\color{black!40!green}
\draw[->] (D) to (E);
}
{\color{blue}
\draw[->] (E) to (F);
}
{\color{black!40!green}
\draw[->] (F) to (G);
\draw[->] (G) to (H);
}
{\color{blue}
\draw[->] (H) to (I);
\draw[->] (I) to (J);
}
{\color{black!40!green}
\draw[->] (J) to (K);
}
{\color{blue}
\draw[->] (K) to (L);
}
{\color{black!40!green}
\draw[->] (L) to (M);
\draw[->] (M) to (N);
\draw[->] (N) to (O);
}
\end{tikzpicture}\end{center}
\begin{center}Figure 8: W\sphinxhyphen{}cycle
\end{center}
In the figures of these schemes, white circles stand for \(\nu\) steps of an iterative solver,
black circles represent a direct solver, blue arrows illustrate a restriction and green arrows illustrate a prolongation.


\section{Grid transfer}
\label{\detokenize{basics:grid-transfer}}
As we have seen in the previous sections, the multigrid algorithm requires the ability to
prolongate vectors from \(\mathbb{R}^{n_{l}}\) to \(\mathbb{R}^{n_{l-1}}\).
We will only show how the grid transfer operations work for conforming finite elements.
For information on how to deal with non\sphinxhyphen{}conforming finite element spaces, please refer to {[}3{]}.
Let \(\left\{\varphi_1^l, \dots, \varphi_{n_{l}}^l\right\}\) and
\(\left\{\varphi_1^{l-1}, \dots, \varphi_{n_{l-1}}^{l-1}\right\}\) be some given bases of
\(V^l\) and \(V^{l-1}\).
Due to the conformity of the finite element spaces,
\(V^{l-1} \subset V^l\) holds and there exists a matrix \(I^{l-1}_l \in \mathbb{R}^{n_{-1} \times n_l}\)
such that
\begin{equation*}
\begin{split}\begin{pmatrix}
\varphi_1^{l-1} \\
\vdots \\
\varphi_{n_{l-1}}^{l-1}
\end{pmatrix} = I^{l-1}_l
\begin{pmatrix}
\varphi_1^{l} \\
\vdots \\
\varphi_{n_{l}}^{l}
\end{pmatrix}.\end{split}
\end{equation*}
The matrix \(I^{l-1}_l\) is called the {\color{blue}restriction matrix} and its transpose \(I^{l}_{l-1} = \left(I^{l-1}_l\right)^T\) is called the {\color{blue}prolongation matrix.}
These matrices are dependent on the finite elements that are being used and on the way that the grids have been refined.
They have only very few non\sphinxhyphen{}zero entries and thus are stored as sparse matrices.
Furthermore, they also have a significant impact on the rate of convergence of the multigrid algorithm {[}3{]}{]}.
Additionally, for linear partial differential equations the identity
\begin{equation*}
\begin{split}A_{l-1} = I^{l}_{l-1} A_l I^{l-1}_l\end{split}
\end{equation*}
is fulfilled. Before taking a look at the actual implementation in our code,
it is helpful to a see how the the grid transfer works for one dimensional linear finite elements.

\begin{sphinxadmonition}{note}{Grid transfer in 1D}

\begin{figure}[H]
\centering
\includegraphics[width=0.35\columnwidth]
{grid_transfer.png}
\end{figure}

\begin{center}Figure 9: Basis functions on the first two levels
\end{center}
It holds
\begin{equation*}
\begin{split}\varphi_1^0 &= \varphi_1^1 + \frac{1}{2}\varphi_3^1, \\
\varphi_2^0 &= \varphi_2^1 + \frac{1}{2}\varphi_3^1.\end{split}
\end{equation*}
Consequently the restriction matrix reads
\begin{equation*}
\begin{split}I_1^0 =
\begin{bmatrix}
1 & & \frac{1}{2} \\
& 1 & \frac{1}{2}
\end{bmatrix}.\end{split}
\end{equation*}\end{sphinxadmonition}

We decided to follow these rules to create the interpolation matrix \(I_{l-1}^l\):
\begin{itemize}
\item {} 
if the i.th node already exists on level \({l-1}\), then \(\left(I_{l-1}^l\right)_{i,i} = 1\)

\item {} 
else get the indices of the parents of the i.th node, then \(\left(I_{l-1}^l\right)_{i,\text{parent}_1} = \frac{1}{2}\) and \(\left(I_{l-1}^l\right)_{i,\text{parent}_2} = \frac{1}{2}\)

\end{itemize}

The rest of this matrix is filled with zeros. Doing this for \({l=1}\) yields the prolongation matrix
\begin{equation*}
\begin{split}I_0^1 =
\begin{bmatrix}
1 & & & & & & &  \\
& 1 & & & & & &  \\
& & 1 & & & & &  \\
& & & 1 & & & &  \\
& & & & 1 & & &  \\
& & & & & 1 & &  \\
& & & & & & 1 &  \\
& & & & & & & 1  \\
\frac{1}{2}&\frac{1}{2} & & & & & &  \\
& \frac{1}{2}&\frac{1}{2} & & & & &  \\
\frac{1}{2}& & &\frac{1}{2} & & & & \\
& \frac{1}{2}& & & \frac{1}{2}& & & \\
& & &\frac{1}{2} &\frac{1}{2} & & & \\
& &\frac{1}{2} & & &\frac{1}{2} & & \\
& & & &\frac{1}{2} &\frac{1}{2} & & \\
& & & \frac{1}{2}& & & \frac{1}{2}&  \\
& & & & \frac{1}{2}& & & \frac{1}{2}\\
& & & & & & \frac{1}{2}& \frac{1}{2}\\
\frac{1}{2}& & & &\frac{1}{2} & & & \\
& & &\frac{1}{2} & & & & \frac{1}{2} \\
&\frac{1}{2} & & & & \frac{1}{2}& &  \\
\end{bmatrix}.\end{split}
\end{equation*}
For our kind of prolongation matrix, the restriction matrix is given by
\begin{equation*}
\begin{split}I_l^{l-1} = \frac{1}{4}\left( I_{l-1}^l \right)^T.\end{split}
\end{equation*}
At this point, we should also mention how the boundary conditions can be applied
in the multigrid algorithm. The start vector of this method should be the zero vector on which the Dirichlet boundary conditions should be applied.
Note that Dirichlet boundary conditions need to be applied to the output vectors of the prolongation and restriction,
but here {\color{red}{all Dirichlet boundary conditions are set to be homogeneous}}.


\section{References}
\label{\detokenize{basics:references}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Sven Beuchler. \sphinxstyleemphasis{Lecture notes in ‘Multigrid and domain decomposition.’} April 2020.

\item {} 
Thomas Wick. \sphinxstyleemphasis{Numerical Methods for Partial Differential Equations.} 2020. URL: \sphinxurl{https://doi.org/10.15488/9248}.

\item {} 
Dietrich Braess. \sphinxstyleemphasis{Finite Elemente.} Springer Berlin Heidelberg, 2013. DOI: 10.1007/978\sphinxhyphen{}3\sphinxhyphen{}642\sphinxhyphen{}34797\sphinxhyphen{}9. URL: \sphinxurl{https://doi.org/10.1007\%2F978-3-642-34797-9}.

\item {} 
Chao Chen. “Geometric multigrid for eddy current problems”. PhD thesis. 2012.

\item {} 
Julian Roth. “Geometric Multigrid Methods for Maxwell’s Equations”. Bachelor thesis. 2020.

\item {} 
Thomas Richter and Thomas Wick. Einführung in die numerische Mathematik \sphinxhyphen{} Begriffe, Konzepte und zahlreiche Anwendungsbeispiele. Springer, 2017.

\end{enumerate}


\chapter{Results of Multigrid for Convection Diffusion}
\label{\detokenize{Multigrid:Results-of-Multigrid-for-Convection-Diffusion}}\label{\detokenize{Multigrid::doc}}

\section{Imports}
\label{\detokenize{Multigrid:Imports}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[1]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{k+kn}{from} \PYG{n+nn}{main} \PYG{k+kn}{import} \PYG{n}{inputParameters}\PYG{p}{,} \PYG{n}{runDemo}
\PYG{k+kn}{import} \PYG{n+nn}{logging}
\PYG{n}{logging}\PYG{o}{.}\PYG{n}{basicConfig}\PYG{p}{(}\PYG{n}{level}\PYG{o}{=}\PYG{n}{logging}\PYG{o}{.}\PYG{n}{INFO} \PYG{p}{,} \PYG{n+nb}{format}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{[}\PYG{l+s+si}{\PYGZpc{}(asctime)s}\PYG{l+s+s1}{] \PYGZhy{} [}\PYG{l+s+si}{\PYGZpc{}(levelname)s}\PYG{l+s+s1}{] \PYGZhy{} }\PYG{l+s+si}{\PYGZpc{}(message)s}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}
}


\section{Set parameters}
\label{\detokenize{Multigrid:Set-parameters}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[2]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{inputParameters}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
==================
* DEFAULT VALUES *
==================
LEVELS              = 5
SHOW\_GRIDS          = False
DEGREE              = 1
CYCLE               = W
MAX\_ITER            = 100
SMOOTHING\_STEPS     = 2
SMOOTHER            = Jacobi
OMEGA               = 0.8

Would you like to change some values? (Y/N): Y
Number of MG levels (default: 5) = 10
Plot grids (default: False) =
Degree of FE (default: 1) =
Multigrid cycle (default: W; supported: 'V','W') =
Maximum number of MG iterations (default: 100) =
Number of smoothing steps (default: 2) =
Smoother type (default: Jacobi; supported: 'Jacobi','GaussSeidel') =
Relaxation parameter omega (default: 0.8) =

=================
* CUSTOM VALUES *
=================
LEVELS              = 10
SHOW\_GRIDS          = False
DEGREE              = 1
CYCLE               = W
MAX\_ITER            = 100
SMOOTHING\_STEPS     = 2
SMOOTHER            = Jacobi
OMEGA               = 0.8

\end{sphinxVerbatim}
}


\section{Demo}
\label{\detokenize{Multigrid:Demo}}
Now that the user has inserted the parameters of the multigrid algorithm, we start by solving the two\sphinxhyphen{}grid method, refine the grid, solve the three\sphinxhyphen{}grid method, etc.

What we would expect from the theory is that the number of mulitgrid iterations needed should be constant and thus independent of the number of levels. This property is approximately fulfilled in our simulation. Furthermore, the total computation time should depend linearly on the number of DoFs. This can’t be observed here, since for us the assembly of the level matrices is a big bottleneck and consumes the most time. When taking a closer look at the time stamps of the logs and comparing that
to where the program currently is in our code, one might notice that after the assembly the time for the actual process of solving the linear equation system approximately doubles when we add a new level. The number of DoFs quadruples with every refinement. Thus the time of the multigrid solver linearly depends on the number of degrees of freedom.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[3]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{runDemo}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{nbsphinx-stderr}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[2020-06-17 14:32:55,887] - [INFO] - +-----------------------------------------+
[2020-06-17 14:32:55,888] - [INFO] - +    MULTIGRID (LEVELS =  2)              +
[2020-06-17 14:32:55,888] - [INFO] - +-----------------------------------------+
[2020-06-17 14:32:56,049] - [INFO] - Number of DoFs: 21 (by level: 8,21)
[2020-06-17 14:32:56,094] - [INFO] - Defect:         5.43e-13
[2020-06-17 14:32:56,094] - [INFO] - GMG iterations: 14
[2020-06-17 14:32:56,095] - [INFO] - Total time:     209 ms
[2020-06-17 14:32:56,096] - [INFO] -
[2020-06-17 14:32:56,096] - [INFO] - +-----------------------------------------+
[2020-06-17 14:32:56,097] - [INFO] - +    MULTIGRID (LEVELS =  3)              +
[2020-06-17 14:32:56,097] - [INFO] - +-----------------------------------------+
[2020-06-17 14:32:56,262] - [INFO] - Number of DoFs: 65 (by level: 8,21,65)
[2020-06-17 14:32:56,347] - [INFO] - Defect:         4.54e-13
[2020-06-17 14:32:56,347] - [INFO] - GMG iterations: 15
[2020-06-17 14:32:56,348] - [INFO] - Total time:     251 ms
[2020-06-17 14:32:56,348] - [INFO] -
[2020-06-17 14:32:56,349] - [INFO] - +-----------------------------------------+
[2020-06-17 14:32:56,349] - [INFO] - +    MULTIGRID (LEVELS =  4)              +
[2020-06-17 14:32:56,349] - [INFO] - +-----------------------------------------+
[2020-06-17 14:32:56,614] - [INFO] - Number of DoFs: 225 (by level: 8,21,65,225)
[2020-06-17 14:32:56,789] - [INFO] - Defect:         8.66e-13
[2020-06-17 14:32:56,790] - [INFO] - GMG iterations: 14
[2020-06-17 14:32:56,792] - [INFO] - Total time:     443 ms
[2020-06-17 14:32:56,792] - [INFO] -
[2020-06-17 14:32:56,793] - [INFO] - +-----------------------------------------+
[2020-06-17 14:32:56,793] - [INFO] - +    MULTIGRID (LEVELS =  5)              +
[2020-06-17 14:32:56,794] - [INFO] - +-----------------------------------------+
[2020-06-17 14:32:57,189] - [INFO] - Number of DoFs: 833 (by level: 8,21,65,225,833)
[2020-06-17 14:32:57,531] - [INFO] - Defect:         6.6e-13
[2020-06-17 14:32:57,532] - [INFO] - GMG iterations: 14
[2020-06-17 14:32:57,536] - [INFO] - Total time:     744 ms
[2020-06-17 14:32:57,537] - [INFO] -
[2020-06-17 14:32:57,537] - [INFO] - +-----------------------------------------+
[2020-06-17 14:32:57,538] - [INFO] - +    MULTIGRID (LEVELS =  6)              +
[2020-06-17 14:32:57,538] - [INFO] - +-----------------------------------------+
[2020-06-17 14:32:58,253] - [INFO] - Number of DoFs: 3201 (by level: 8,21,65,225,833,3201)
[2020-06-17 14:32:58,953] - [INFO] - Defect:         6.57e-13
[2020-06-17 14:32:58,954] - [INFO] - GMG iterations: 13
[2020-06-17 14:32:58,967] - [INFO] - Total time:     1 s 430 ms
[2020-06-17 14:32:58,968] - [INFO] -
[2020-06-17 14:32:58,969] - [INFO] - +-----------------------------------------+
[2020-06-17 14:32:58,969] - [INFO] - +    MULTIGRID (LEVELS =  7)              +
[2020-06-17 14:32:58,970] - [INFO] - +-----------------------------------------+
[2020-06-17 14:33:01,179] - [INFO] - Number of DoFs: 12545 (by level: 8,21,65,225,833,3201,12545)
[2020-06-17 14:33:02,991] - [INFO] - Defect:         4.27e-13
[2020-06-17 14:33:02,992] - [INFO] - GMG iterations: 13
[2020-06-17 14:33:03,068] - [INFO] - Total time:     4 s 100 ms
[2020-06-17 14:33:03,069] - [INFO] -
[2020-06-17 14:33:03,069] - [INFO] - +-----------------------------------------+
[2020-06-17 14:33:03,070] - [INFO] - +    MULTIGRID (LEVELS =  8)              +
[2020-06-17 14:33:03,070] - [INFO] - +-----------------------------------------+
[2020-06-17 14:33:11,378] - [INFO] - Number of DoFs: 49665 (by level: 8,21,65,225,833,3201,12545,49665)
[2020-06-17 14:33:15,631] - [INFO] - Defect:         9.59e-13
[2020-06-17 14:33:15,632] - [INFO] - GMG iterations: 12
[2020-06-17 14:33:15,873] - [INFO] - Total time:     12 s 804 ms
[2020-06-17 14:33:15,874] - [INFO] -
[2020-06-17 14:33:15,874] - [INFO] - +-----------------------------------------+
[2020-06-17 14:33:15,875] - [INFO] - +    MULTIGRID (LEVELS =  9)              +
[2020-06-17 14:33:15,875] - [INFO] - +-----------------------------------------+
[2020-06-17 14:33:49,566] - [INFO] - Number of DoFs: 197633 (by level: 8,21,65,225,833,3201,12545,49665,197633)
[2020-06-17 14:34:01,356] - [INFO] - Defect:         4.53e-13
[2020-06-17 14:34:01,356] - [INFO] - GMG iterations: 12
[2020-06-17 14:34:02,231] - [INFO] - Total time:     46 s 356 ms
[2020-06-17 14:34:02,232] - [INFO] -
[2020-06-17 14:34:02,232] - [INFO] - +-----------------------------------------+
[2020-06-17 14:34:02,232] - [INFO] - +    MULTIGRID (LEVELS = 10)              +
[2020-06-17 14:34:02,233] - [INFO] - +-----------------------------------------+
[2020-06-17 14:36:10,700] - [INFO] - Number of DoFs: 788481 (by level: 8,21,65,225,833,3201,12545,49665,197633,788481)
[2020-06-17 14:36:45,769] - [INFO] - Defect:         8.76e-13
[2020-06-17 14:36:45,770] - [INFO] - GMG iterations: 11
[2020-06-17 14:36:49,207] - [INFO] - Total time:     2 min 46 s 974 ms
[2020-06-17 14:36:49,207] - [INFO] -
\end{sphinxVerbatim}
}


\chapter{License}
\label{\detokenize{license:license}}\label{\detokenize{license::doc}}
MIT License

Copyright (c) 2020 Julian Roth, Max Schröder

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the “Software”), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


\chapter{Help}
\label{\detokenize{help:help}}\label{\detokenize{help::doc}}
If you have any questions, feel free to contact us via \sphinxhref{mailto:mathmerizing@gmail.com}{mathmerizing@gmail.com}.




\renewcommand{\indexname}{Index}
\printindex
\end{document}